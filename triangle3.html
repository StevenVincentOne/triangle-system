<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Intelligent System Model with Animation</title>
    <style>
        body {
            background-color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: Arial, sans-serif;
            color: white;
        }
        #dashboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: #444;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .dashboard-section {
            width: 100%;
            padding: 10px;
            background-color: #555;
            margin-bottom: 10px;
        }
        .dashboard-section h2 {
            margin: 0 0 10px 0;
            text-align: center;
        }
        .dashboard-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            flex-wrap: wrap;
        }
        .dashboard-item {
            flex: 1 1 23%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
        }
        .dashboard-item span {
            margin: 0 5px;
        }
        .editable {
            background-color: #555;
            border: 1px solid #777;
            color: white;
            padding: 2px 5px;
            margin: 0 5px;
            width: 60px;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        canvas {
            background-color: black;
            margin-bottom: 20px;
            cursor: default;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .preset-button {
            background-color: yellow;
            color: black;
        }
        button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #legend {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            max-width: 800px;
        }
        #legend h3 {
            margin-top: 0;
        }
        .lock-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .lock-checkbox {
            display: flex;
            align-items: center;
        }
        .lock-checkbox label {
            margin-left: 5px;
        }
        /* Additional styles for the animation controls */
        .animation-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .animation-controls select,
        .animation-controls input {
            padding: 5px;
            font-size: 14px;
        }
        .animation-controls button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
        }
        .animation-controls button:hover {
            background-color: #0b7dda;
        }
        
        /* New Styles for Information Panel and Main Content */
        .main-content {
            display: flex;
            flex-direction: row;
            width: 100%;
            justify-content: center;
            align-items: flex-start;
            gap: 20px; /* space between info panel and canvas */
            padding: 20px;
        }

        #information-panel {
            background-color: #444;
            padding: 20px;
            border-radius: 5px;
            color: white;
            width: 300px; /* adjust as needed */
            box-sizing: border-box;
            max-height: 800px;
            overflow-y: auto;
        }

        #information-panel h2 {
            text-align: center;
            margin-top: 0;
        }

        #information-panel .info-section {
            margin-bottom: 20px;
        }

        #information-panel h3,
        #information-panel h4 {
            margin-bottom: 10px;
        }

        #information-panel p {
            margin: 5px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; color: white; margin-top: 20px;">Intelligent System Model with Animation</h1>

    <div id="dashboard">
        <!-- System Section -->
        <div id="system-section" class="dashboard-section">
            <h2>System</h2>
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Perimeter:</span>
                    <span class="editable" data-system="perimeter"></span>
                </div>
                <div class="dashboard-item">
                    <span>Area:</span>
                    <span class="editable" data-area="system"></span>
                </div>
            </div>
        </div>

        <!-- Subsystems Section -->
        <div id="subsystems-section" class="dashboard-section">
            <h2>Subsystems</h2>
            <!-- Subsystems rows here -->
            <!-- Areas Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Subsystem 1</span>
                </div>
                <div class="dashboard-item">
                    <span>Subsystem 2</span>
                </div>
                <div class="dashboard-item">
                    <span>Subsystem 3</span>
                </div>
            </div>
            <!-- Areas Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Area:</span>
                    <span class="editable" data-subsystem="1" data-property="area"></span>
                </div>
                <div class="dashboard-item">
                    <span>Area:</span>
                    <span class="editable" data-subsystem="2" data-property="area"></span>
                </div>
                <div class="dashboard-item">
                    <span>Area:</span>
                    <span class="editable" data-subsystem="3" data-property="area"></span>
                </div>
            </div>
            <!-- Perimeters Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Perimeter:</span>
                    <span class="editable" data-subsystem="1" data-property="perimeter"></span>
                </div>
                <div class="dashboard-item">
                    <span>Perimeter:</span>
                    <span class="editable" data-subsystem="2" data-property="perimeter"></span>
                </div>
                <div class="dashboard-item">
                    <span>Perimeter:</span>
                    <span class="editable" data-subsystem="3" data-property="perimeter"></span>
                </div>
            </div>
            <!-- Centroid Angles Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Centroid Angle:</span>
                    <span class="editable" data-subsystem="1" data-property="centroid-angle"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Centroid Angle:</span>
                    <span class="editable" data-subsystem="2" data-property="centroid-angle"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Centroid Angle:</span>
                    <span class="editable" data-subsystem="3" data-property="centroid-angle"></span>°
                </div>
            </div>
            <!-- Adjacent Subangles Group A -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Adj. Subangle N2:</span>
                    <span class="editable" data-subsystem="1" data-property="adj-subangle-a"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Adj. Subangle N1:</span>
                    <span class="editable" data-subsystem="2" data-property="adj-subangle-a"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Adj. Subangle N3:</span>
                    <span class="editable" data-subsystem="3" data-property="adj-subangle-a"></span>°
                </div>
            </div>
            <!-- Adjacent Subangles Group B -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Adj. Subangle N1:</span>
                    <span class="editable" data-subsystem="1" data-property="adj-subangle-b"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Adj. Subangle N3:</span>
                    <span class="editable" data-subsystem="2" data-property="adj-subangle-b"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Adj. Subangle N2:</span>
                    <span class="editable" data-subsystem="3" data-property="adj-subangle-b"></span>°
                </div>
            </div>
        </div>

        <!-- Channels Section -->
        <div id="channels-section" class="dashboard-section">
            <h2>Channels</h2>
            <!-- Node Channel Lengths Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>NC1 (N1-N2):</span>
                    <span class="editable" data-edge="nc1"></span>
                </div>
                <div class="dashboard-item">
                    <span>NC2 (N1-N3):</span>
                    <span class="editable" data-edge="nc2"></span>
                </div>
                <div class="dashboard-item">
                    <span>NC3 (N2-N3):</span>
                    <span class="editable" data-edge="nc3"></span>
                </div>
            </div>
            <!-- Median Channel Lengths Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>N1-I:</span>
                    <span class="editable" data-median="n1i"></span>
                </div>
                <div class="dashboard-item">
                    <span>N2-I:</span>
                    <span class="editable" data-median="n2i"></span>
                </div>
                <div class="dashboard-item">
                    <span>N3-I:</span>
                    <span class="editable" data-median="n3i"></span>
                </div>
            </div>
        </div>

        <!-- Nodes Section -->
        <div id="nodes-section" class="dashboard-section">
            <h2>Nodes</h2>
            <!-- Positions Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>N1 Position:</span>
                    x=<span class="editable" data-node="n1" data-coord="x"></span>,
                    y=<span class="editable" data-node="n1" data-coord="y"></span>
                </div>
                <div class="dashboard-item">
                    <span>N2 Position:</span>
                    x=<span class="editable" data-node="n2" data-coord="x"></span>,
                    y=<span class="editable" data-node="n2" data-coord="y"></span>
                </div>
                <div class="dashboard-item">
                    <span>N3 Position:</span>
                    x=<span class="editable" data-node="n3" data-coord="x"></span>,
                    y=<span class="editable" data-node="n3" data-coord="y"></span>
                </div>
            </div>
            <!-- Angles Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>N1 Angle:</span>
                    <span class="editable" data-node="n1" data-coord="angle"></span>°
                </div>
                <div class="dashboard-item">
                    <span>N2 Angle:</span>
                    <span class="editable" data-node="n2" data-coord="angle"></span>°
                </div>
                <div class="dashboard-item">
                    <span>N3 Angle:</span>
                    <span class="editable" data-node="n3" data-coord="angle"></span>°
                </div>
            </div>
        </div>

        <!-- Centers Section -->
        <div id="centers-section" class="dashboard-section">
            <h2>Centers</h2>
            <div class="dashboard-row">
                <!-- Centroid (Intelligence) -->
                <div class="dashboard-item">
                    <span>Centroid I:</span>
                    x=<span class="editable" data-node="intelligence" data-coord="x"></span>,
                    y=<span class="editable" data-node="intelligence" data-coord="y"></span>
                </div>
                <!-- Incenter -->
                <div class="dashboard-item">
                    <span>Incenter:</span>
                    x=<span id="incenter-x"></span>,
                    y=<span id="incenter-y"></span>
                </div>
            </div>
            <!-- Incircle Area and Perimeter -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Incircle Area:</span>
                    <span id="incircle-area"></span>
                </div>
                <div class="dashboard-item">
                    <span>Incircle Perimeter:</span>
                    <span id="incircle-perimeter"></span>
                </div>
            </div>
            <!-- Angles at I (SS1, SS2, SS3) -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Angle SS1:</span>
                    <span class="editable" data-angle="ss1"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Angle SS2:</span>
                    <span class="editable" data-angle="ss2"></span>°
                </div>
                <div class="dashboard-item">
                    <span>Angle SS3:</span>
                    <span class="editable" data-angle="ss3"></span>°
                </div>
            </div>
        </div>
    </div>

    <!-- Lock Controls -->
    <div class="lock-controls">
        <div class="lock-checkbox">
            <input type="checkbox" class="lock-checkbox-input" data-node="n1" id="lock-n1">
            <label for="lock-n1">Lock N1</label>
        </div>
        <div class="lock-checkbox">
            <input type="checkbox" class="lock-checkbox-input" data-node="n2" id="lock-n2">
            <label for="lock-n2">Lock N2</label>
        </div>
        <div class="lock-checkbox">
            <input type="checkbox" class="lock-checkbox-input" data-node="n3" id="lock-n3">
            <label for="lock-n3">Lock N3</label>
        </div>
        <div class="lock-checkbox">
            <input type="checkbox" id="lock-centroid">
            <label for="lock-centroid">Lock I</label>
        </div>
    </div>

    <!-- Controls placed below dashboard -->
    <div class="controls">
        <button id="equilateral" class="preset-button">Equilateral</button>
        <button id="isosceles" class="preset-button">Isosceles</button>
        <button id="scalene" class="preset-button">Scalene</button>
        <button id="right" class="preset-button">Right</button>
        <button id="acute" class="preset-button">Acute</button>
        <button id="obtuse" class="preset-button">Obtuse</button>
        <button id="toggleMidpoints">Midpoints</button>
        <button id="toggleIncircle">Incircle</button>
        <button id="toggleIncenter">Incenter</button>
        <button id="toggleMedians">Medians</button>
        <button id="toggleAreas">Areas</button>
    </div>

    <!-- Animation Controls -->
    <div class="animation-controls">
        <select id="animation-parameter">
            <option value="angle-n1">Angle at N1</option>
            <option value="angle-n2">Angle at N2</option>
            <option value="angle-n3">Angle at N3</option>
            <option value="edge-nc1">Edge NC1 (N1-N2)</option>
            <option value="edge-nc2">Edge NC2 (N1-N3)</option>
            <option value="edge-nc3">Edge NC3 (N2-N3)</option>
            <option value="median-n1i">Median N1-I</option>
            <option value="median-n2i">Median N2-I</option>
            <option value="median-n3i">Median N3-I</option>
            <option value="area">Area</option>
            <option value="perimeter">Perimeter</option>
        </select>
        <input type="number" id="animation-start" placeholder="Start Value">
        <input type="number" id="animation-end" placeholder="End Value">
        <button id="start-animation">Animate</button>
    </div>

    <!-- Main Content: Information Panel and Canvas -->
    <div class="main-content">
        <div id="information-panel">
            <h2>Information Panel</h2>
            <div class="info-section">
                <h3>Distances</h3>
                <p>d Centroid to Incenter: <span id="d-centroid-incenter">0</span></p>
                <h4>d Midpoint to Tangent</h4>
                <p>NC1: <span id="d-midpoint-tangent-nc1">0</span></p>
                <p>NC2: <span id="d-midpoint-tangent-nc2">0</span></p>
                <p>NC3: <span id="d-midpoint-tangent-nc3">0</span></p>
            </div>
            <div class="info-section">
                <h3>Ratios</h3>
                <h4>r Midpoint to Tangent</h4>
                <p>NC1: <span id="r-midpoint-tangent-nc1">0</span></p>
                <p>NC2: <span id="r-midpoint-tangent-nc2">0</span></p>
                <p>NC3: <span id="r-midpoint-tangent-nc3">0</span></p>
            </div>
        </div>
        <canvas id="canvas" width="1000" height="800"></canvas>
    </div>

    <div id="legend">
        <h3>Legend:</h3>
        <p>N1, N2, N3: Main nodes of the triangle</p>
        <p>I: Centroid of the triangle</p>
        <p>Incenter: Point where angle bisectors meet</p>
        <p>Incircle: Circle inscribed within the triangle</p>
        <p>NC1, NC2, NC3: Edge lengths (Node Channels)</p>
        <p>N1-I, N2-I, N3-I: Median Channel lengths</p>
        <p>Yellow Dots: Midpoints of the edges</p>
        <p>Light Blue Dots: Points of tangency with incircle</p>
    </div>

    <script>
        // ----- Constants and Variables -----
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toggleMediansBtn = document.getElementById('toggleMedians');
        const toggleAreasBtn = document.getElementById('toggleAreas');
        const lockCentroidCheckbox = document.getElementById('lock-centroid');
        const toggleMidpointsBtn = document.getElementById('toggleMidpoints');
        const toggleIncircleBtn = document.getElementById('toggleIncircle');
        const toggleIncenterBtn = document.getElementById('toggleIncenter');
        const lockCheckboxes = document.querySelectorAll('.lock-checkbox-input');

        // Preset Buttons
        const equilateralBtn = document.getElementById('equilateral');
        const isoscelesBtn = document.getElementById('isosceles');
        const scaleneBtn = document.getElementById('scalene');
        const rightBtn = document.getElementById('right');
        const acuteBtn = document.getElementById('acute');
        const obtuseBtn = document.getElementById('obtuse');

        // Animation Controls
        const animationParameterSelect = document.getElementById('animation-parameter');
        const animationStartInput = document.getElementById('animation-start');
        const animationEndInput = document.getElementById('animation-end');
        const startAnimationButton = document.getElementById('start-animation');

        // Information Panel Elements
        const infoCentroidToIncenter = document.getElementById('d-centroid-incenter');
        const infoMidpointTangentNC1 = document.getElementById('d-midpoint-tangent-nc1');
        const infoMidpointTangentNC2 = document.getElementById('d-midpoint-tangent-nc2');
        const infoMidpointTangentNC3 = document.getElementById('d-midpoint-tangent-nc3');
        const infoRatioTangentNC1 = document.getElementById('r-midpoint-tangent-nc1');
        const infoRatioTangentNC2 = document.getElementById('r-midpoint-tangent-nc2');
        const infoRatioTangentNC3 = document.getElementById('r-midpoint-tangent-nc3');

        // Define BASE_Y to fix the base of the triangle (N2-N3) horizontally
        const BASE_Y = -150; // Adjust this value as needed to position the base

        let system = {};
        let showConnections = true;
        let showAreas = true;
        let showMidpoints = true;
        let showIncircle = true;
        let showIncenter = true;
        let draggingNode = null;
        const EPSILON = 1e-6;

        // Object to track locked nodes
        const lockedNodes = {
            n1: false,
            n2: false,
            n3: false,
        };

        // Variable to track if the centroid is being dragged
        let draggingCentroid = false;
        let centroidLocked = false;
        let lockedCentroidPosition = { x: 0, y: 0 };

        // Animation Variables
        let animationRequestId = null;
        let animationStartTime = null;
        const animationDuration = 2000; // Animation duration in milliseconds
        let animationParameter = null;
        let animationStartValue = null;
        let animationEndValue = null;

        // ----- Initialization Function -----
        function initializeSystem(preset = 'equilateral') {
            const side = 300;
            const height = (Math.sqrt(3) / 2) * side;

            if (preset === 'equilateral') {
                // Equilateral triangle
                system = {
                    n1: { x: 0, y: 2 * height / 3 },
                    n2: { x: -side / 2, y: BASE_Y }, // Fixed Y-coordinate
                    n3: { x: side / 2, y: BASE_Y },  // Fixed Y-coordinate
                };
            } else if (preset === 'isosceles') {
                // Isosceles triangle
                system = {
                    n1: { x: 0, y: height / 2 },
                    n2: { x: -side / 2, y: BASE_Y }, // Fixed Y-coordinate
                    n3: { x: side / 2, y: BASE_Y },  // Fixed Y-coordinate
                };
            } else if (preset === 'scalene') {
                // Scalene triangle
                system = {
                    n1: { x: -100, y: 150 },
                    n2: { x: 50, y: BASE_Y },  // Fixed Y-coordinate
                    n3: { x: 150, y: BASE_Y }, // Fixed Y-coordinate
                };
            } else if (preset === 'right') {
                // Right triangle
                system = {
                    n1: { x: 0, y: 0 },
                    n2: { x: 0, y: BASE_Y },    // Fixed Y-coordinate
                    n3: { x: 300, y: BASE_Y },  // Fixed Y-coordinate
                };
            } else if (preset === 'acute') {
                // Acute triangle
                system = {
                    n1: { x: -100, y: 100 },
                    n2: { x: 100, y: BASE_Y },  // Fixed Y-coordinate
                    n3: { x: 150, y: BASE_Y },  // Fixed Y-coordinate
                };
            } else if (preset === 'obtuse') {
                // Obtuse triangle
                system = {
                    n1: { x: -200, y: 0 },
                    n2: { x: 0, y: BASE_Y },    // Fixed Y-coordinate
                    n3: { x: 50, y: BASE_Y },   // Fixed Y-coordinate
                };
            }

            // Reset lock checkboxes
            lockCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            lockCentroidCheckbox.checked = false;
            centroidLocked = false;
            lockedNodes.n1 = false;
            lockedNodes.n2 = false;
            lockedNodes.n3 = false;

            updateDerivedPoints();
            updateDashboard();
            drawSystem();
        }

        // ----- Derived Points Calculation -----
        function updateDerivedPoints() {
            const N1 = system.n1;
            const N2 = system.n2;
            const N3 = system.n3;
            // Recalculate centroid
            system.intelligence = {
                x: (N1.x + N2.x + N3.x) / 3,
                y: (N1.y + N2.y + N3.y) / 3,
            };
            // Calculate midpoints
            system.midpoints = {
                m1: { x: (N2.x + N3.x) / 2, y: BASE_Y }, // Midpoint opposite N1 (NC3) Fixed Y-coordinate
                m2: { x: (N1.x + N3.x) / 2, y: (N1.y + N3.y) / 2 }, // Midpoint opposite N2 (NC2)
                m3: { x: (N1.x + N2.x) / 2, y: (N1.y + N2.y) / 2 }, // Midpoint opposite N3 (NC1)
            };
            // Calculate incenter
            system.incenter = calculateIncenter();
            // Calculate incircle radius
            system.incircleRadius = calculateIncircleRadius();
            // Calculate points of tangency
            system.tangencyPoints = calculateIncircleTangencyPoints();
        }

        // ----- Drawing Functions -----
        function drawSystem() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            // Translate origin to center of canvas
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(1, -1); // Invert Y-axis

            // Draw axes
            drawAxes();

            // Draw main triangle
            ctx.beginPath();
            ctx.moveTo(system.n1.x, system.n1.y);
            ctx.lineTo(system.n2.x, system.n2.y);
            ctx.lineTo(system.n3.x, system.n3.y);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();

            if (showAreas) {
                drawSubtriangles();
            }

            if (showConnections) {
                drawConnections();
            }

            if (showMidpoints) {
                // Draw midpoints and lines to centroid
                drawMidpoints();
            }

            // Draw incircle
            if (showIncircle) {
                drawIncircle();
                drawTangencyPoints();
            }

            // Draw nodes
            drawNode(system.n1, 'red', 'N1');
            drawNode(system.n2, 'blue', 'N2');
            drawNode(system.n3, 'green', 'N3');

            // Draw centroid
            drawNode(system.intelligence, 'white', 'I');

            // Draw incenter
            if (showIncenter) {
                drawNode(system.incenter, 'cyan', 'Incenter');
            }

            // Display angles and lengths
            displayInfo();

            ctx.restore();
        }

        function drawAxes() {
            ctx.strokeStyle = 'gray';
            ctx.lineWidth = 1;

            // Draw X axis
            ctx.beginPath();
            ctx.moveTo(-canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, 0);
            ctx.stroke();

            // Draw Y axis
            ctx.beginPath();
            ctx.moveTo(0, -canvas.height / 2);
            ctx.lineTo(0, canvas.height / 2);
            ctx.stroke();
        }

        function drawSubtriangles() {
            const subtriangles = [
                { points: [system.n1, system.n2, system.intelligence], color: 'rgba(255, 0, 0, 0.3)' },
                { points: [system.n3, system.n1, system.intelligence], color: 'rgba(0, 255, 0, 0.3)' },
                { points: [system.n2, system.n3, system.intelligence], color: 'rgba(0, 0, 255, 0.3)' },
            ];

            subtriangles.forEach((tri) => {
                ctx.beginPath();
                ctx.moveTo(tri.points[0].x, tri.points[0].y);
                ctx.lineTo(tri.points[1].x, tri.points[1].y);
                ctx.lineTo(tri.points[2].x, tri.points[2].y);
                ctx.closePath();
                ctx.fillStyle = tri.color;
                ctx.fill();
            });
        }

        function drawConnections() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(system.n1.x, system.n1.y);
            ctx.lineTo(system.intelligence.x, system.intelligence.y);
            ctx.moveTo(system.n2.x, system.n2.y);
            ctx.lineTo(system.intelligence.x, system.intelligence.y);
            ctx.moveTo(system.n3.x, system.n3.y);
            ctx.lineTo(system.intelligence.x, system.intelligence.y);
            ctx.stroke();
        }

        function drawMidpoints() {
            ctx.fillStyle = 'yellow';
            ctx.strokeStyle = 'yellow';
            ctx.setLineDash([5, 5]); // Dotted lines

            for (let key of ['m1', 'm2', 'm3']) {
                const midpoint = system.midpoints[key];
                // Draw midpoint
                ctx.beginPath();
                ctx.arc(midpoint.x, midpoint.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                // Draw line to centroid
                ctx.beginPath();
                ctx.moveTo(system.intelligence.x, system.intelligence.y);
                ctx.lineTo(midpoint.x, midpoint.y);
                ctx.stroke();
            }

            ctx.setLineDash([]); // Reset to solid lines
        }

        function drawIncircle() {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(system.incenter.x, system.incenter.y, system.incircleRadius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawTangencyPoints() {
            ctx.fillStyle = 'lightblue';
            system.tangencyPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function drawNode(point, color, label) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            ctx.fill();

            // Draw label
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(label, point.x + 8, point.y + 8);
        }

        function displayInfo() {
            const angles = calculateAngles();
            const lengths = calculateLengths();

            ctx.save();
            ctx.scale(1, -1); // Flip text back to normal
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';

            // Move N1 label above its angle reading
            ctx.fillText('N1', system.n1.x - 10, -system.n1.y - 25);
            ctx.fillText(`${angles.n1.toFixed(1)}°`, system.n1.x - 10, -system.n1.y - 10);

            // Move N2 label and angle to the left of the node
            ctx.fillText('N2', system.n2.x - 50, -system.n2.y + 5);
            ctx.fillText(`${angles.n2.toFixed(1)}°`, system.n2.x - 50, -system.n2.y + 20);

            // N3 label and angle
            ctx.fillText('N3', system.n3.x + 10, -system.n3.y + 5);
            ctx.fillText(`${angles.n3.toFixed(1)}°`, system.n3.x + 10, -system.n3.y + 20);

            // Label edges as NC1, NC2, NC3 and move labels outside edges
            // Edge N1-N2: NC1
            const midPointNC1 = {
                x: (system.n1.x + system.n2.x) / 2,
                y: (system.n1.y + system.n2.y) / 2,
            };
            ctx.fillText(`NC1`, midPointNC1.x - 40, -midPointNC1.y + 20);
            ctx.fillText(`${lengths.l3.toFixed(1)}`, midPointNC1.x - 40, -midPointNC1.y + 35);

            // Edge N1-N3: NC2
            const midPointNC2 = {
                x: (system.n1.x + system.n3.x) / 2,
                y: (system.n1.y + system.n3.y) / 2,
            };
            ctx.fillText(`NC2`, midPointNC2.x + 10, -midPointNC2.y - 10);
            ctx.fillText(`${lengths.l2.toFixed(1)}`, midPointNC2.x + 10, -midPointNC2.y + 5);

            // Edge N2-N3: NC3
            const midPointNC3 = {
                x: (system.n2.x + system.n3.x) / 2,
                y: (system.n2.y + system.n3.y) / 2,
            };
            ctx.fillText(`NC3`, midPointNC3.x - 50, -midPointNC3.y + 20);
            ctx.fillText(`${lengths.l1.toFixed(1)}`, midPointNC3.x - 50, -midPointNC3.y + 35);

            ctx.restore();
        }

        // ----- Angle and Length Calculations -----
        function calculateAngles() {
            return {
                n1: calculateAngle(system.n2, system.n1, system.n3),
                n2: calculateAngle(system.n3, system.n2, system.n1),
                n3: calculateAngle(system.n1, system.n3, system.n2),
            };
        }

        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const dot = v1.x * v2.x + v1.y * v2.y;
            const cross = v1.x * v2.y - v1.y * v2.x;

            let angle = Math.atan2(Math.abs(cross), dot) * (180 / Math.PI);

            if (Math.abs(angle) < EPSILON || Math.abs(180 - angle) < EPSILON) {
                return 0;
            }

            return angle;
        }

        function calculateLengths() {
            return {
                l1: calculateDistance(system.n2, system.n3), // NC3 (N2-N3)
                l2: calculateDistance(system.n1, system.n3), // NC2 (N1-N3)
                l3: calculateDistance(system.n1, system.n2), // NC1 (N1-N2)
            };
        }

        function calculateMedians() {
            return {
                m1: calculateDistance(system.n1, system.intelligence),
                m2: calculateDistance(system.n2, system.intelligence),
                m3: calculateDistance(system.n3, system.intelligence),
            };
        }

        function calculateSubsystems() {
            const subsystems = [];

            // Subsystem 1: N1, N2, I
            subsystems.push(calculateSubsystem(system.n1, system.n2, system.intelligence, 'N1', 'N2'));

            // Subsystem 2: N3, N1, I
            subsystems.push(calculateSubsystem(system.n3, system.n1, system.intelligence, 'N3', 'N1'));

            // Subsystem 3: N2, N3, I
            subsystems.push(calculateSubsystem(system.n2, system.n3, system.intelligence, 'N2', 'N3'));

            return subsystems;
        }

        function calculateSubsystem(nodeA, nodeB, centroid, labelA, labelB) {
            // Calculate area
            const area = Math.abs((nodeA.x * (nodeB.y - centroid.y) + nodeB.x * (centroid.y - nodeA.y) + centroid.x * (nodeA.y - nodeB.y)) / 2);

            // Calculate perimeter
            const side1 = calculateDistance(nodeA, nodeB);
            const side2 = calculateDistance(nodeB, centroid);
            const side3 = calculateDistance(centroid, nodeA);
            const perimeter = side1 + side2 + side3;

            // Calculate centroid angle
            const centroidAngle = calculateAngle(nodeA, centroid, nodeB);

            // Adjacent Subangles at nodeA and nodeB
            const angleAtNodeA = calculateAngle(centroid, nodeA, nodeB);
            const angleAtNodeB = calculateAngle(nodeA, nodeB, centroid);

            return {
                area,
                perimeter,
                centroidAngle,
                adjSubangleA: angleAtNodeA,
                adjSubangleB: angleAtNodeB,
                labelA,
                labelB,
            };
        }

        function calculateSubsystemAngles() {
            // Angles at I in the subtriangles
            const angleSS1 = calculateAngle(system.n2, system.intelligence, system.n1);
            const angleSS2 = calculateAngle(system.n1, system.intelligence, system.n3);
            const angleSS3 = calculateAngle(system.n3, system.intelligence, system.n2);

            return {
                ss1: angleSS1,
                ss2: angleSS2,
                ss3: angleSS3,
            };
        }

        function calculateDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        // ----- Incenter and Incircle Calculations -----
        function calculateIncenter() {
            const a = calculateDistance(system.n2, system.n3);
            const b = calculateDistance(system.n1, system.n3);
            const c = calculateDistance(system.n1, system.n2);

            const perimeter = a + b + c;

            const x = (a * system.n1.x + b * system.n2.x + c * system.n3.x) / perimeter;
            const y = (a * system.n1.y + b * system.n2.y + c * system.n3.y) / perimeter;

            return { x, y };
        }

        function calculateIncircleRadius() {
            const area = calculateArea();
            const perimeter = calculatePerimeter();

            return (2 * area) / perimeter;
        }

        function calculateIncircleTangencyPoints() {
            const { n1, n2, n3, incenter } = system;

            // Helper function to calculate the point of tangency on side between p1 and p2
            function tangencyPoint(p1, p2) {
                const a = calculateDistance(p1, p2);
                const b = calculateDistance(incenter, p1);
                const c = calculateDistance(incenter, p2);
                const s = (a + b + c) / 2;
                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
                const h = (2 * area) / a;

                // Vector from p1 to p2
                const vx = p2.x - p1.x;
                const vy = p2.y - p1.y;
                const length = Math.hypot(vx, vy);
                const ux = vx / length;
                const uy = vy / length;

                // Distance along side from p1 to point
                const d = Math.sqrt(b * b - h * h);

                return {
                    x: p1.x + ux * d,
                    y: p1.y + uy * d,
                };
            }

            return [
                tangencyPoint(n1, n2), // NC1 (N1-N2)
                tangencyPoint(n2, n3), // NC3 (N2-N3)
                tangencyPoint(n3, n1), // NC2 (N3-N1)
            ];
        }

        // ----- Mouse Position Helpers -----
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left - canvas.width / 2,
                y: (evt.clientY - rect.top - canvas.height / 2) * -1,
            };
        }

        function distanceToNode(point, node) {
            return Math.hypot(point.x - node.x, point.y - node.y);
        }

        // ----- Event Listeners for Dragging -----
        canvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(canvas, e);
            const nodes = ['n1', 'n2', 'n3'];
            let nodeFound = false;

            for (let n of nodes) {
                if (distanceToNode(mousePos, system[n]) < 10) {
                    draggingNode = n;
                    nodeFound = true;
                    break;
                }
            }

            // Check if centroid is clicked
            if (!nodeFound && distanceToNode(mousePos, system.intelligence) < 10) {
                draggingCentroid = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const mousePos = getMousePos(canvas, e);

            if (draggingNode) {
                moveNode(draggingNode, mousePos);
                updateDerivedPoints();
                if (centroidLocked) {
                    adjustForLockedCentroid();
                }
                drawSystem();
                updateDashboard();
            } else if (draggingCentroid) {
                if (!centroidLocked) {
                    adjustCentroidPosition(mousePos.x, mousePos.y);
                }
                drawSystem();
                updateDashboard();
            } else {
                // Change cursor style when hovering over nodes or centroid
                const overNode = ['n1', 'n2', 'n3'].some(n => distanceToNode(mousePos, system[n]) < 10);
                const overCentroid = distanceToNode(mousePos, system.intelligence) < 10;

                if (overNode || overCentroid) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggingNode = null;
            draggingCentroid = false;
        });

        // ----- Toggle Button Event Listeners -----
        toggleMediansBtn.addEventListener('click', () => {
            showConnections = !showConnections;
            drawSystem();
        });

        toggleAreasBtn.addEventListener('click', () => {
            showAreas = !showAreas;
            drawSystem();
        });

        toggleMidpointsBtn.addEventListener('click', () => {
            showMidpoints = !showMidpoints;
            drawSystem();
        });

        toggleIncircleBtn.addEventListener('click', () => {
            showIncircle = !showIncircle;
            drawSystem();
        });

        toggleIncenterBtn.addEventListener('click', () => {
            showIncenter = !showIncenter;
            drawSystem();
        });

        // ----- Preset Buttons Event Listeners -----
        equilateralBtn.addEventListener('click', () => {
            initializeSystem('equilateral');
        });

        isoscelesBtn.addEventListener('click', () => {
            initializeSystem('isosceles');
        });

        scaleneBtn.addEventListener('click', () => {
            initializeSystem('scalene');
        });

        rightBtn.addEventListener('click', () => {
            initializeSystem('right');
        });

        acuteBtn.addEventListener('click', () => {
            initializeSystem('acute');
        });

        obtuseBtn.addEventListener('click', () => {
            initializeSystem('obtuse');
        });

        // ----- Lock Checkbox Event Listeners -----
        lockCentroidCheckbox.addEventListener('change', function () {
            centroidLocked = this.checked;
            if (centroidLocked) {
                lockedCentroidPosition = { ...system.intelligence };
            }
        });

        lockCheckboxes.forEach((checkbox) => {
            const node = checkbox.dataset.node;
            checkbox.addEventListener('change', function () {
                lockedNodes[node] = this.checked;
            });
        });

        // ----- Dashboard Update Function -----
        function updateDashboard() {
            const angles = calculateAngles();
            const lengths = calculateLengths();
            const medians = calculateMedians();
            const subsystemAngles = calculateSubsystemAngles();
            const subsystems = calculateSubsystems();

            // Update perimeter
            const perimeter = lengths.l1 + lengths.l2 + lengths.l3;
            document.querySelector(`[data-system="perimeter"]`).textContent = perimeter.toFixed(1);

            // Update centroid position
            document.querySelector(`[data-node="intelligence"][data-coord="x"]`).textContent = system.intelligence.x.toFixed(1);
            document.querySelector(`[data-node="intelligence"][data-coord="y"]`).textContent = system.intelligence.y.toFixed(1);

            // Update system area
            document.querySelector(`[data-area="system"]`).textContent = calculateArea().toFixed(1);

            // Update angles at I
            document.querySelector(`[data-angle="ss1"]`).textContent = subsystemAngles.ss1.toFixed(1);
            document.querySelector(`[data-angle="ss2"]`).textContent = subsystemAngles.ss2.toFixed(1);
            document.querySelector(`[data-angle="ss3"]`).textContent = subsystemAngles.ss3.toFixed(1);

            // Update node positions and angles
            for (let node of ['n1', 'n2', 'n3']) {
                document.querySelector(`[data-node="${node}"][data-coord="x"]`).textContent = system[node].x.toFixed(1);
                document.querySelector(`[data-node="${node}"][data-coord="y"]`).textContent = system[node].y.toFixed(1);
                document.querySelector(`[data-node="${node}"][data-coord="angle"]`).textContent = angles[node].toFixed(1);
            }

            // Update edge lengths
            document.querySelector(`[data-edge="nc1"]`).textContent = lengths.l3.toFixed(1); // NC1 (N1-N2)
            document.querySelector(`[data-edge="nc2"]`).textContent = lengths.l2.toFixed(1); // NC2 (N1-N3)
            document.querySelector(`[data-edge="nc3"]`).textContent = lengths.l1.toFixed(1); // NC3 (N2-N3)

            // Update median lengths
            document.querySelector(`[data-median="n1i"]`).textContent = medians.m1.toFixed(1);
            document.querySelector(`[data-median="n2i"]`).textContent = medians.m2.toFixed(1);
            document.querySelector(`[data-median="n3i"]`).textContent = medians.m3.toFixed(1);

            // Update subsystem data
            subsystems.forEach((subsystem, index) => {
                const idx = index + 1;
                document.querySelector(`[data-subsystem="${idx}"][data-property="area"]`).textContent = subsystem.area.toFixed(1);
                document.querySelector(`[data-subsystem="${idx}"][data-property="perimeter"]`).textContent = subsystem.perimeter.toFixed(1);
                document.querySelector(`[data-subsystem="${idx}"][data-property="centroid-angle"]`).textContent = subsystem.centroidAngle.toFixed(1);
                document.querySelector(`[data-subsystem="${idx}"][data-property="adj-subangle-a"]`).textContent = subsystem.adjSubangleA.toFixed(1);
                document.querySelector(`[data-subsystem="${idx}"][data-property="adj-subangle-b"]`).textContent = subsystem.adjSubangleB.toFixed(1);
            });

            // Update incenter position
            document.getElementById('incenter-x').textContent = system.incenter.x.toFixed(1);
            document.getElementById('incenter-y').textContent = system.incenter.y.toFixed(1);

            // Update incircle area and perimeter
            const incircleArea = Math.PI * Math.pow(system.incircleRadius, 2);
            const incirclePerimeter = 2 * Math.PI * system.incircleRadius;
            document.getElementById('incircle-area').textContent = incircleArea.toFixed(1);
            document.getElementById('incircle-perimeter').textContent = incirclePerimeter.toFixed(1);

            // ----- Update Information Panel -----
            updateInformationPanel();
        }

        // ----- Editable Elements Event Listeners -----
        document.querySelectorAll('.editable').forEach((el) => {
            el.addEventListener('click', function () {
                const self = this;
                self.contentEditable = true;
                // Select the entire text when clicked
                setTimeout(() => {
                    const range = document.createRange();
                    range.selectNodeContents(self);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }, 0);

                self.focus();

                self.addEventListener('keydown', function handler(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        self.contentEditable = false;
                        const newValue = parseFloat(self.textContent);
                        processEditableInput(self, newValue);
                        self.removeEventListener('keydown', handler);
                    }
                });

                self.addEventListener('blur', function handler() {
                    self.contentEditable = false;
                    const newValue = parseFloat(self.textContent);
                    processEditableInput(self, newValue);
                    self.removeEventListener('blur', handler);
                });
            });
        });

        function processEditableInput(element, newValue) {
            const node = element.dataset.node;
            const coord = element.dataset.coord;
            const edge = element.dataset.edge;
            const median = element.dataset.median;
            const area = element.dataset.area;
            const angle = element.dataset.angle;
            const systemData = element.dataset.system;
            const subsystem = element.dataset.subsystem;
            const property = element.dataset.property;

            if (!isNaN(newValue)) {
                if (coord === 'angle') {
                    if (newValue <= 0 || newValue >= 180) {
                        alert('Please enter an angle between 0° and 180°.');
                    } else {
                        adjustAngle(node, newValue);
                    }
                } else if (edge) {
                    // Adjust edge length
                    adjustEdgeLength(edge, newValue);
                } else if (median) {
                    // Adjust median length
                    adjustMedianLength(median, newValue);
                } else if (area) {
                    if (area === 'system') {
                        adjustSystemArea(newValue);
                    }
                } else if (angle) {
                    // Adjusting angles at intelligence point
                    alert('Adjusting angles at the centroid is not supported.');
                } else if (systemData === 'perimeter') {
                    adjustPerimeter(newValue);
                } else if (node === 'intelligence') {
                    // Adjust centroid position
                    adjustCentroid(coord, newValue);
                } else if (subsystem && property) {
                    alert('Adjusting subsystem properties is not supported directly.');
                } else if (coord === 'x' || coord === 'y') {
                    if (node === 'n2' || node === 'n3') {
                        if (coord === 'y') {
                            alert('Cannot change Y-coordinate of the base nodes.');
                            // Reset to BASE_Y
                            system[node].y = BASE_Y;
                            element.textContent = BASE_Y.toFixed(1);
                        } else if (coord === 'x') {
                            system[node].x = newValue;
                            system[node].y = BASE_Y; // Ensure Y is fixed
                            element.textContent = newValue.toFixed(1);
                            updateDerivedPoints();
                            drawSystem();
                            updateDashboard();
                        }
                    } else {
                        system[node][coord] = newValue;
                        updateDerivedPoints();
                        if (centroidLocked) {
                            adjustForLockedCentroid();
                        }
                        drawSystem();
                        updateDashboard();
                    }
                }
            }
        }

        // ----- Adjustment Functions -----
        function moveNode(node, newPos) {
            if (!lockedNodes[node]) {
                if (node === 'n2' || node === 'n3') {
                    // Only allow X movement for base nodes
                    system[node].x = newPos.x;
                    system[node].y = BASE_Y; // Keep Y fixed
                } else {
                    system[node].x = newPos.x;
                    system[node].y = newPos.y;
                }
            }
        }

        function adjustForLockedCentroid() {
            updateDerivedPoints();
            const deltaX = lockedCentroidPosition.x - system.intelligence.x;
            const deltaY = lockedCentroidPosition.y - system.intelligence.y;

            const movableNodes = ['n1', 'n2', 'n3'].filter(n => !lockedNodes[n]);
            const numMovableNodes = movableNodes.length;

            if (numMovableNodes === 0) {
                alert('All nodes are locked. Cannot adjust to maintain centroid.');
                return;
            }

            for (let node of movableNodes) {
                if (node === 'n2' || node === 'n3') {
                    // Only adjust X for base nodes
                    system[node].x += deltaX / numMovableNodes;
                    // Y remains BASE_Y
                    system[node].y = BASE_Y;
                } else {
                    system[node].x += deltaX / numMovableNodes;
                    system[node].y += deltaY / numMovableNodes;
                }
            }

            updateDerivedPoints();
        }

        function adjustCentroid(coord, newValue) {
            if (centroidLocked) {
                alert('Centroid is locked. Cannot adjust its coordinates.');
                return;
            }
            const oldCentroid = { x: system.intelligence.x, y: system.intelligence.y };
            const newCentroid = { ...oldCentroid };
            if (coord === 'x') {
                newCentroid.x = newValue;
            } else if (coord === 'y') {
                newCentroid.y = newValue;
            }
            adjustCentroidPosition(newCentroid.x, newCentroid.y);
            drawSystem();
            updateDashboard();
        }

        function adjustCentroidPosition(newX, newY) {
            // Get the list of locked nodes
            const locked = [];
            const unlocked = [];

            for (let node of ['n1', 'n2', 'n3']) {
                if (lockedNodes[node]) {
                    locked.push(node);
                } else {
                    unlocked.push(node);
                }
            }

            if (locked.length === 3) {
                alert('All nodes are locked. Cannot adjust the centroid.');
                return;
            }

            // Old centroid
            const oldCentroid = { x: system.intelligence.x, y: system.intelligence.y };
            // New centroid
            const newCentroid = { x: newX, y: newY };

            if (locked.length === 2) {
                // Move the unlocked node
                const fixedNode1 = system[locked[0]];
                const fixedNode2 = system[locked[1]];
                const movingNode = unlocked[0];

                system[movingNode].x = 3 * newCentroid.x - fixedNode1.x - fixedNode2.x;
                system[movingNode].y = 3 * newCentroid.y - fixedNode1.y - fixedNode2.y;

                // Ensure base nodes remain horizontal
                system['n2'].y = BASE_Y;
                system['n3'].y = BASE_Y;
            } else if (locked.length === 1) {
                // Move the two unlocked nodes proportionally
                const deltaX = 3 * (newCentroid.x - oldCentroid.x);
                const deltaY = 3 * (newCentroid.y - oldCentroid.y);
                const totalWeight = unlocked.length;

                for (let node of unlocked) {
                    if (node === 'n2' || node === 'n3') {
                        system[node].x += deltaX / totalWeight;
                        // Y remains fixed
                        system[node].y = BASE_Y;
                    } else {
                        system[node].x += deltaX / totalWeight;
                        system[node].y += deltaY / totalWeight;
                    }
                }
            } else if (locked.length === 0) {
                // Move all three nodes equally
                const deltaX = newCentroid.x - oldCentroid.x;
                const deltaY = newCentroid.y - oldCentroid.y;

                for (let node of ['n1', 'n2', 'n3']) {
                    if (node === 'n2' || node === 'n3') {
                        system[node].x += deltaX;
                        // Y remains fixed
                        system[node].y = BASE_Y;
                    } else {
                        system[node].x += deltaX;
                        system[node].y += deltaY;
                    }
                }
            }

            updateDerivedPoints();
        }

        function adjustAngle(node, newAngle, suppressAlert = false) {
            if (lockedNodes[node]) {
                if (!suppressAlert) alert(`Node ${node.toUpperCase()} is locked. Cannot adjust its angle.`);
                return;
            }

            if (centroidLocked) {
                if (!suppressAlert) alert('Centroid is locked. Cannot adjust angle while centroid is locked.');
                return;
            }

            // Identify the nodes
            const movingNode = node;
            let fixedNodes = ['n1', 'n2', 'n3'].filter(n => n !== movingNode);

            // Check for locked fixed nodes
            let lockedFixedNodes = fixedNodes.filter(n => lockedNodes[n]);
            let unlockedFixedNodes = fixedNodes.filter(n => !lockedNodes[n]);

            if (lockedFixedNodes.length === 2) {
                if (!suppressAlert) alert('Cannot adjust angle with both adjacent nodes locked.');
                return;
            }

            let fixedNode1, fixedNode2;

            if (lockedFixedNodes.length === 1) {
                fixedNode1 = system[lockedFixedNodes[0]];
                fixedNode2 = system[unlockedFixedNodes[0]];
            } else {
                // If both adjacent nodes are unlocked, arbitrarily fix one
                fixedNode1 = system[fixedNodes[0]];
                fixedNode2 = system[fixedNodes[1]];
            }

            const angleRadians = (newAngle * Math.PI) / 180;

            if (angleRadians <= 0 || angleRadians >= Math.PI) {
                if (!suppressAlert) alert('Please enter an angle between 0° and 180°.');
                return;
            }

            const a = calculateDistance(fixedNode1, fixedNode2);

            const tanHalfC = Math.tan(angleRadians / 2);
            if (Math.abs(tanHalfC) < EPSILON) {
                if (!suppressAlert) alert('Invalid angle value.');
                return;
            }

            const h = (a / 2) / tanHalfC;

            // Vector from fixedNode1 to fixedNode2
            const dx = fixedNode2.x - fixedNode1.x;
            const dy = fixedNode2.y - fixedNode1.y;
            const angleToXAxis = Math.atan2(dy, dx);

            // Calculate the position of the moving node
            const Rx = (fixedNode1.x + fixedNode2.x) / 2 + h * Math.sin(angleToXAxis);
            const Ry = (fixedNode1.y + fixedNode2.y) / 2 - h * Math.cos(angleToXAxis);

            system[movingNode].x = Rx;
            system[movingNode].y = Ry;

            // Ensure base nodes remain horizontal
            if (movingNode === 'n2' || movingNode === 'n3') {
                system[movingNode].y = BASE_Y;
            }

            updateDerivedPoints();
            if (centroidLocked) {
                adjustForLockedCentroid();
            }
            drawSystem();
            updateDashboard();
        }

        function adjustEdgeLength(edge, newLength, suppressAlert = false) {
            let nodeA, nodeB;
            if (edge === 'nc1') {
                nodeA = 'n1';
                nodeB = 'n2';
            } else if (edge === 'nc2') {
                nodeA = 'n1';
                nodeB = 'n3';
            } else if (edge === 'nc3') {
                nodeA = 'n2';
                nodeB = 'n3';
            } else {
                return;
            }

            if (lockedNodes[nodeA] && lockedNodes[nodeB]) {
                if (!suppressAlert) alert(`Both nodes ${nodeA.toUpperCase()} and ${nodeB.toUpperCase()} are locked. Cannot adjust the length.`);
                return;
            }

            // Temporarily lock the centroid
            let wasCentroidLocked = centroidLocked;
            if (!centroidLocked) {
                centroidLocked = true;
                lockedCentroidPosition = { ...system.intelligence };
            }

            const currentLength = calculateDistance(system[nodeA], system[nodeB]);
            const scalingFactor = newLength / currentLength;

            if (lockedNodes[nodeA]) {
                // Adjust nodeB
                system[nodeB].x = system[nodeA].x + (system[nodeB].x - system[nodeA].x) * scalingFactor;
                system[nodeB].y = BASE_Y; // Ensure Y is fixed
            } else if (lockedNodes[nodeB]) {
                // Adjust nodeA
                system[nodeA].x = system[nodeB].x + (system[nodeA].x - system[nodeB].x) * scalingFactor;
                // Y remains unchanged for N1
                // If nodeA is not a base node, y can change
                if (nodeA !== 'n2' && nodeA !== 'n3') {
                    system[nodeA].y = system[nodeA].y; // No change
                }
            } else {
                // Adjust both nodes equally
                const midpoint = {
                    x: (system[nodeA].x + system[nodeB].x) / 2,
                    y: BASE_Y, // Ensure y of midpoint for NC3 is fixed
                };
                const vectorA = {
                    x: system[nodeA].x - midpoint.x,
                    y: system[nodeA].y - midpoint.y,
                };
                const vectorB = {
                    x: system[nodeB].x - midpoint.x,
                    y: system[nodeB].y - midpoint.y,
                };

                system[nodeA].x = midpoint.x + vectorA.x * scalingFactor;
                system[nodeA].y = midpoint.y + vectorA.y * scalingFactor;

                system[nodeB].x = midpoint.x + vectorB.x * scalingFactor;
                system[nodeB].y = midpoint.y + vectorB.y * scalingFactor;

                // Ensure Y of base nodes remains fixed
                if (nodeA === 'n2' || nodeA === 'n3') {
                    system[nodeA].y = BASE_Y;
                }
                if (nodeB === 'n2' || nodeB === 'n3') {
                    system[nodeB].y = BASE_Y;
                }
            }

            updateDerivedPoints();

            drawSystem();
            updateDashboard();

            // Restore previous centroid lock state
            if (!wasCentroidLocked) {
                centroidLocked = false;
            }
        }

        function adjustMedianLength(median, newLength, suppressAlert = false) {
            let node;
            if (median === 'n1i') {
                node = 'n1';
            } else if (median === 'n2i') {
                node = 'n2';
            } else if (median === 'n3i') {
                node = 'n3';
            } else {
                return;
            }

            if (lockedNodes[node]) {
                if (!suppressAlert) alert(`Node ${node.toUpperCase()} is locked. Cannot adjust median length.`);
                return;
            }

            // Temporarily lock the centroid
            let wasCentroidLocked = centroidLocked;
            if (!centroidLocked) {
                centroidLocked = true;
                lockedCentroidPosition = { ...system.intelligence };
            }

            const currentLength = calculateDistance(system[node], system.intelligence);
            const scalingFactor = newLength / currentLength;

            if (node === 'n2' || node === 'n3') {
                // Only adjust X for base nodes
                system[node].x = system.intelligence.x + (system[node].x - system.intelligence.x) * scalingFactor;
                system[node].y = BASE_Y; // Ensure Y is fixed
            } else {
                // Adjust other nodes normally
                system[node].x = system.intelligence.x + (system[node].x - system.intelligence.x) * scalingFactor;
                system[node].y = system.intelligence.y + (system[node].y - system.intelligence.y) * scalingFactor;
            }

            updateDerivedPoints();

            drawSystem();
            updateDashboard();

            // Restore previous centroid lock state
            if (!wasCentroidLocked) {
                centroidLocked = false;
            }
        }

        function adjustSystemArea(newArea, suppressAlert = false) {
            const currentArea = calculateArea();
            const scalingFactor = Math.sqrt(newArea / currentArea);

            // Scale all node positions relative to the centroid
            const centroid = system.intelligence;

            ['n1', 'n2', 'n3'].forEach(node => {
                system[node].x = centroid.x + (system[node].x - centroid.x) * scalingFactor;
                if (node === 'n2' || node === 'n3') {
                    system[node].y = BASE_Y; // Ensure Y is fixed
                } else {
                    system[node].y = centroid.y + (system[node].y - centroid.y) * scalingFactor;
                }
            });

            updateDerivedPoints();
            drawSystem();
            updateDashboard();
        }

        function adjustPerimeter(newPerimeter, suppressAlert = false) {
            const currentPerimeter = calculatePerimeter();
            const scalingFactor = newPerimeter / currentPerimeter;

            // Scale all node positions relative to the centroid
            const centroid = system.intelligence;

            ['n1', 'n2', 'n3'].forEach(node => {
                system[node].x = centroid.x + (system[node].x - centroid.x) * scalingFactor;
                if (node === 'n2' || node === 'n3') {
                    system[node].y = BASE_Y; // Ensure Y is fixed
                } else {
                    system[node].y = centroid.y + (system[node].y - centroid.y) * scalingFactor;
                }
            });

            updateDerivedPoints();
            drawSystem();
            updateDashboard();
        }

        // ----- Area and Perimeter Calculations -----
        function calculateArea() {
            const { n1, n2, n3 } = system;
            return Math.abs((n1.x * (n2.y - n3.y) + n2.x * (n3.y - n1.y) + n3.x * (n1.y - n2.y)) / 2);
        }

        function calculatePerimeter() {
            const lengths = calculateLengths();
            return lengths.l1 + lengths.l2 + lengths.l3;
        }

        // ----- Animation Functions -----
        startAnimationButton.addEventListener('click', () => {
            animationParameter = animationParameterSelect.value;
            animationStartValue = parseFloat(animationStartInput.value);
            animationEndValue = parseFloat(animationEndInput.value);

            if (isNaN(animationStartValue) || isNaN(animationEndValue)) {
                alert('Please enter valid numeric values for start and end values.');
                return;
            }

            startAnimation();
        });

        function startAnimation() {
            if (animationRequestId) {
                cancelAnimationFrame(animationRequestId);
            }
            animationStartTime = null;
            animationRequestId = requestAnimationFrame(animate);
        }

        function animate(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            const currentValue = animationStartValue + (animationEndValue - animationStartValue) * progress;

            // Update the parameter based on currentValue
            updateAnimatedParameter(animationParameter, currentValue);

            drawSystem();
            updateDashboard();

            if (progress < 1) {
                animationRequestId = requestAnimationFrame(animate);
            } else {
                animationRequestId = null;
            }
        }

        function updateAnimatedParameter(parameter, value) {
            switch (parameter) {
                case 'angle-n1':
                    adjustAngle('n1', value, true);
                    break;
                case 'angle-n2':
                    adjustAngle('n2', value, true);
                    break;
                case 'angle-n3':
                    adjustAngle('n3', value, true);
                    break;
                case 'edge-nc1':
                    adjustEdgeLength('nc1', value, true);
                    break;
                case 'edge-nc2':
                    adjustEdgeLength('nc2', value, true);
                    break;
                case 'edge-nc3':
                    adjustEdgeLength('nc3', value, true);
                    break;
                case 'median-n1i':
                    adjustMedianLength('n1i', value, true);
                    break;
                case 'median-n2i':
                    adjustMedianLength('n2i', value, true);
                    break;
                case 'median-n3i':
                    adjustMedianLength('n3i', value, true);
                    break;
                case 'area':
                    adjustSystemArea(value, true);
                    break;
                case 'perimeter':
                    adjustPerimeter(value, true);
                    break;
                default:
                    break;
            }
        }

        // ----- Information Panel Update Function -----
        function updateInformationPanel() {
            const centroid = system.intelligence;
            const incenter = system.incenter;
            const d_centroid_incenter = calculateDistance(centroid, incenter);
            infoCentroidToIncenter.textContent = d_centroid_incenter.toFixed(1);

            const tangencyPoints = system.tangencyPoints; // [NC1, NC3, NC2]
            const midpoints = system.midpoints;

            // Mapping:
            // m3 => NC1 (N1-N2) => tangencyPoints[0]
            // m2 => NC2 (N1-N3) => tangencyPoints[2]
            // m1 => NC3 (N2-N3) => tangencyPoints[1]

            const d_mt_nc1 = calculateDistance(midpoints.m3, tangencyPoints[0]); // NC1
            const d_mt_nc2 = calculateDistance(midpoints.m2, tangencyPoints[2]); // NC2
            const d_mt_nc3 = calculateDistance(midpoints.m1, tangencyPoints[1]); // NC3

            infoMidpointTangentNC1.textContent = d_mt_nc1.toFixed(1);
            infoMidpointTangentNC2.textContent = d_mt_nc2.toFixed(1);
            infoMidpointTangentNC3.textContent = d_mt_nc3.toFixed(1);

            // r Midpoint to Tangent: Distance divided by incircle radius
            const r_mt_nc1 = system.incircleRadius !== 0 ? (d_mt_nc1 / system.incircleRadius) : 0;
            const r_mt_nc2 = system.incircleRadius !== 0 ? (d_mt_nc2 / system.incircleRadius) : 0;
            const r_mt_nc3 = system.incircleRadius !== 0 ? (d_mt_nc3 / system.incircleRadius) : 0;

            infoRatioTangentNC1.textContent = r_mt_nc1.toFixed(3);
            infoRatioTangentNC2.textContent = r_mt_nc2.toFixed(3);
            infoRatioTangentNC3.textContent = r_mt_nc3.toFixed(3);
        }

        // ----- Main Event Listener Setup -----
        // Initialize the system with default preset
        initializeSystem('equilateral');
    </script>
</body>
</html>