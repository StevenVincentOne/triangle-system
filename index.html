<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Intelligent System Model with Animation</title>
    <style>
    /* General Styles */
    body {
        background-color: #2c3e50; /* Darker background for better contrast */
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        font-family: Arial, sans-serif;
        color: white;
    }

    h1 {
        text-align: center;
        color: #ecf0f1;
        margin: 20px 0;
    }

    /* Dashboard Styles */
    #dashboard {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 90%;
        max-width: 1200px;
        background-color: #34495e;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }

    .dashboard-section {
        width: 100%;
        padding: 15px;
        background-color: #3c5975;
        margin-bottom: 15px;
        border-radius: 8px;
    }

    .dashboard-section h2 {
        margin: 0 0 10px 0;
        text-align: center;
        color: #ecf0f1;
    }

    .dashboard-row {
        display: flex;
        justify-content: space-around;
        width: 100%;
        flex-wrap: wrap;
        gap: 10px;
    }

    .dashboard-item {
        flex: 1 1 22%;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        background-color: #4b6584;
        border-radius: 5px;
    }

    .dashboard-item label {
        margin-bottom: 5px;
        font-weight: bold;
        cursor: pointer;
    }

    .dashboard-item input, .dashboard-item span {
        width: 80%;
        padding: 5px;
        border: none;
        border-radius: 3px;
        text-align: center;
        font-size: 14px;
        background-color: #7f8c8d;
        color: #2c3e50;
    }

    /* Controls Styles */
    .controls, .animation-controls, .lock-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 15px;
    }

    button, select {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s;
    }

    button {
        background-color: #1abc9c;
        color: white;
    }

    button:hover {
        background-color: #16a085;
    }

    .preset-button {
        background-color: #f39c12;
        color: white;
    }

    .preset-button:hover {
        background-color: #e67e22;
    }

    .animation-controls select, .animation-controls input {
        padding: 5px;
        font-size: 14px;
        border-radius: 3px;
        border: none;
    }

    /* Canvas Styles */
    canvas {
        background-color: #2c3e50;
        border: 2px solid #34495e;
        border-radius: 10px;
        cursor: grab;
        max-width: 100%;
        height: auto;
    }

    canvas:active {
        cursor: grabbing;
    }

    /* Legend Styles */
    #legend {
        background-color: rgba(52, 73, 94, 0.9);
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        max-width: 800px;
        width: 90%;
    }

    #legend h3 {
        margin-top: 0;
        color: #ecf0f1;
    }

    #legend p {
        margin: 5px 0;
        color: #bdc3c7;
    }

    /* Tooltip Styles */
    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        width: 150px;
        background-color: #34495e;
        color: #ecf0f1;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%; /* Position above the element */
        left: 50%;
        margin-left: -75px;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .dashboard-item {
            flex: 1 1 45%;
        }
    }

    @media (max-width: 480px) {
        .dashboard-item {
            flex: 1 1 100%;
        }
    }

    /* Locked Nodes Visual Indicator */
    .locked {
        opacity: 0.6;
        position: relative;
    }

    .locked::after {
        content: 'ðŸ”’';
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 16px;
    }

    /* Main Content and Information Panel Styles */
    #main-content {
        display: flex;
        gap: 20px; /* Space between Info Panel and Canvas */
        width: 90%;
        max-width: 1200px;
        margin: 0 auto; /* Center the container */
    }

    /* Information Panel Styles */
    #info-panel {
        background-color: #34495e;
        padding: 20px;
        border-radius: 10px;
        color: #ecf0f1;
        width: 300px; /* Fixed width for the info panel */
        flex-shrink: 0; /* Prevent shrinking when screen is small */
    }

    #info-panel h2 {
        text-align: center;
        margin-bottom: 15px;
    }

    .info-item {
        margin-bottom: 15px;
    }

    .info-item ul {
        list-style-type: none;
        padding-left: 0;
    }

    .info-item li {
        margin: 5px 0;
    }

    /* Canvas and Legend Container */
    #canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1; /* Allow canvas-container to take remaining space */
    }

    /* Adjust Canvas Size Responsively */
    canvas {
        max-width: 100%;
        height: auto;
    }

    /* Responsive Design Enhancements */
    @media (max-width: 768px) {
        #main-content {
            flex-direction: column; /* Stack Info Panel above Canvas */
            align-items: center;
        }

        #info-panel {
            width: 100%; /* Full width on small screens */
        }
    }
    </style>
</head>
<body>
    <h1>Intelligent System Model with Animation</h1>

    <div id="dashboard">
        <!-- System Section -->
        <div id="system-section" class="dashboard-section">
            <h2>System</h2>
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="system-perimeter">Perimeter:</label>
                    <input type="number" id="system-perimeter" data-system="perimeter" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="system-area">Area:</label>
                    <input type="number" id="system-area" data-area="system" step="0.1">
                </div>
            </div>
        </div>

        <!-- Subsystems Section -->
        <div id="subsystems-section" class="dashboard-section">
            <h2>Subsystems</h2>
            <!-- Subsystem Labels -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <span>Subsystem 1</span>
                </div>
                <div class="dashboard-item">
                    <span>Subsystem 2</span>
                </div>
                <div class="dashboard-item">
                    <span>Subsystem 3</span>
                </div>
            </div>
            <!-- Areas Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="subsystem-1-area">Area:</label>
                    <input type="number" id="subsystem-1-area" data-subsystem="1" data-property="area" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-2-area">Area:</label>
                    <input type="number" id="subsystem-2-area" data-subsystem="2" data-property="area" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-3-area">Area:</label>
                    <input type="number" id="subsystem-3-area" data-subsystem="3" data-property="area" step="0.1">
                </div>
            </div>
            <!-- Perimeters Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="subsystem-1-perimeter">Perimeter:</label>
                    <input type="number" id="subsystem-1-perimeter" data-subsystem="1" data-property="perimeter" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-2-perimeter">Perimeter:</label>
                    <input type="number" id="subsystem-2-perimeter" data-subsystem="2" data-property="perimeter" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-3-perimeter">Perimeter:</label>
                    <input type="number" id="subsystem-3-perimeter" data-subsystem="3" data-property="perimeter" step="0.1">
                </div>
            </div>
            <!-- Centroid Angles Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="subsystem-1-centroid-angle">Centroid Angle:</label>
                    <input type="number" id="subsystem-1-centroid-angle" data-subsystem="1" data-property="centroid-angle" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-2-centroid-angle">Centroid Angle:</label>
                    <input type="number" id="subsystem-2-centroid-angle" data-subsystem="2" data-property="centroid-angle" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-3-centroid-angle">Centroid Angle:</label>
                    <input type="number" id="subsystem-3-centroid-angle" data-subsystem="3" data-property="centroid-angle" step="0.1">Â°
                </div>
            </div>
            <!-- Adjacent Subangles Group A -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="subsystem-1-adj-subangle-a">Adj. Subangle N2:</label>
                    <input type="number" id="subsystem-1-adj-subangle-a" data-subsystem="1" data-property="adj-subangle-a" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-2-adj-subangle-a">Adj. Subangle N1:</label>
                    <input type="number" id="subsystem-2-adj-subangle-a" data-subsystem="2" data-property="adj-subangle-a" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-3-adj-subangle-a">Adj. Subangle N3:</label>
                    <input type="number" id="subsystem-3-adj-subangle-a" data-subsystem="3" data-property="adj-subangle-a" step="0.1">Â°
                </div>
            </div>
            <!-- Adjacent Subangles Group B -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="subsystem-1-adj-subangle-b">Adj. Subangle N1:</label>
                    <input type="number" id="subsystem-1-adj-subangle-b" data-subsystem="1" data-property="adj-subangle-b" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-2-adj-subangle-b">Adj. Subangle N3:</label>
                    <input type="number" id="subsystem-2-adj-subangle-b" data-subsystem="2" data-property="adj-subangle-b" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="subsystem-3-adj-subangle-b">Adj. Subangle N2:</label>
                    <input type="number" id="subsystem-3-adj-subangle-b" data-subsystem="3" data-property="adj-subangle-b" step="0.1">Â°
                </div>
            </div>
        </div>

        <!-- Channels Section -->
        <div id="channels-section" class="dashboard-section">
            <h2>Channels</h2>
            <!-- Node Channel Lengths Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="edge-nc1">NC1 (N1-N2):</label>
                    <input type="number" id="edge-nc1" data-edge="nc1" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="edge-nc2">NC2 (N1-N3):</label>
                    <input type="number" id="edge-nc2" data-edge="nc2" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="edge-nc3">NC3 (N2-N3):</label>
                    <input type="number" id="edge-nc3" data-edge="nc3" step="0.1">
                </div>
            </div>
            <!-- Median Channel Lengths Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="median-n1i">N1-I:</label>
                    <input type="number" id="median-n1i" data-median="n1i" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="median-n2i">N2-I:</label>
                    <input type="number" id="median-n2i" data-median="n2i" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="median-n3i">N3-I:</label>
                    <input type="number" id="median-n3i" data-median="n3i" step="0.1">
                </div>
            </div>
        </div>

        <!-- Nodes Section -->
        <div id="nodes-section" class="dashboard-section">
            <h2>Nodes</h2>
            <!-- Positions Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="node-n1-x">N1 Position X:</label>
                    <input type="number" id="node-n1-x" data-node="n1" data-coord="x" step="0.1">
                    <label for="node-n1-y">Y:</label>
                    <input type="number" id="node-n1-y" data-node="n1" data-coord="y" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="node-n2-x">N2 Position X:</label>
                    <input type="number" id="node-n2-x" data-node="n2" data-coord="x" step="0.1">
                    <label for="node-n2-y">Y:</label>
                    <input type="number" id="node-n2-y" data-node="n2" data-coord="y" step="0.1">
                </div>
                <div class="dashboard-item">
                    <label for="node-n3-x">N3 Position X:</label>
                    <input type="number" id="node-n3-x" data-node="n3" data-coord="x" step="0.1">
                    <label for="node-n3-y">Y:</label>
                    <input type="number" id="node-n3-y" data-node="n3" data-coord="y" step="0.1">
                </div>
            </div>
            <!-- Angles Row -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="node-n1-angle">N1 Angle:</label>
                    <input type="number" id="node-n1-angle" data-node="n1" data-coord="angle" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="node-n2-angle">N2 Angle:</label>
                    <input type="number" id="node-n2-angle" data-node="n2" data-coord="angle" step="0.1">Â°
                </div>
                <div class="dashboard-item">
                    <label for="node-n3-angle">N3 Angle:</label>
                    <input type="number" id="node-n3-angle" data-node="n3" data-coord="angle" step="0.1">Â°
                </div>
            </div>
        </div>

        <!-- Centers Section -->
        <div id="centers-section" class="dashboard-section">
            <h2>Centers</h2>
            <div class="dashboard-row">
                <!-- Centroid (Intelligence) -->
                <div class="dashboard-item">
                    <label for="centroid-x">Centroid I X:</label>
                    <input type="number" id="centroid-x" data-node="intelligence" data-coord="x" step="0.1">
                    <label for="centroid-y">Y:</label>
                    <input type="number" id="centroid-y" data-node="intelligence" data-coord="y" step="0.1">
                </div>
                <!-- Incenter -->
                <div class="dashboard-item">
                    <label>Incenter:</label>
                    <input type="number" id="incenter-x" step="0.1" readonly>
                    <input type="number" id="incenter-y" step="0.1" readonly>
                </div>
            </div>
            <!-- Incircle Area and Perimeter -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label>Incircle Area:</label>
                    <input type="number" id="incircle-area" step="0.1" readonly>
                </div>
                <div class="dashboard-item">
                    <label>Incircle Perimeter:</label>
                    <input type="number" id="incircle-perimeter" step="0.1" readonly>
                </div>
            </div>
            <!-- Angles at I (SS1, SS2, SS3) -->
            <div class="dashboard-row">
                <div class="dashboard-item">
                    <label for="angle-ss1">Angle SS1:</label>
                    <input type="number" id="angle-ss1" data-angle="ss1" step="0.1" readonly>Â°
                </div>
                <div class="dashboard-item">
                    <label for="angle-ss2">Angle SS2:</label>
                    <input type="number" id="angle-ss2" data-angle="ss2" step="0.1" readonly>Â°
                </div>
                <div class="dashboard-item">
                    <label for="angle-ss3">Angle SS3:</label>
                    <input type="number" id="angle-ss3" data-angle="ss3" step="0.1" readonly>Â°
                </div>
            </div>
        </div>

        <!-- Lock Controls -->
        <div class="lock-controls">
            <div class="lock-checkbox">
                <input type="checkbox" class="lock-checkbox-input" data-node="n1" id="lock-n1">
                <label for="lock-n1">Lock N1</label>
            </div>
            <div class="lock-checkbox">
                <input type="checkbox" class="lock-checkbox-input" data-node="n2" id="lock-n2">
                <label for="lock-n2">Lock N2</label>
            </div>
            <div class="lock-checkbox">
                <input type="checkbox" class="lock-checkbox-input" data-node="n3" id="lock-n3">
                <label for="lock-n3">Lock N3</label>
            </div>
            <div class="lock-checkbox">
                <input type="checkbox" id="lock-centroid">
                <label for="lock-centroid">Lock I</label>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="controls">
            <button id="equilateral" class="preset-button tooltip">Equilateral
                <span class="tooltiptext">Set triangle to Equilateral</span>
            </button>
            <button id="isosceles" class="preset-button tooltip">Isosceles
                <span class="tooltiptext">Set triangle to Isosceles</span>
            </button>
            <button id="scalene" class="preset-button tooltip">Scalene
                <span class="tooltiptext">Set triangle to Scalene</span>
            </button>
            <button id="right" class="preset-button tooltip">Right
                <span class="tooltiptext">Set triangle to Right-angled</span>
            </button>
            <button id="acute" class="preset-button tooltip">Acute
                <span class="tooltiptext">Set triangle to Acute-angled</span>
            </button>
            <button id="obtuse" class="preset-button tooltip">Obtuse
                <span class="tooltiptext">Set triangle to Obtuse-angled</span>
            </button>
            <button id="toggleMidpoints" class="tooltip">Midpoints
                <span class="tooltiptext">Toggle Midpoints</span>
            </button>
            <button id="toggleIncircle" class="tooltip">Incircle
                <span class="tooltiptext">Toggle Incircle</span>
            </button>
            <button id="toggleIncenter" class="tooltip">Incenter
                <span class="tooltiptext">Toggle Incenter</span>
            </button>
            <button id="toggleMedians" class="tooltip">Medians
                <span class="tooltiptext">Toggle Medians</span>
            </button>
            <button id="toggleAreas" class="tooltip">Areas
                <span class="tooltiptext">Toggle Areas</span>
            </button>
            <!-- Apply Button -->
            <button id="apply-button" class="tooltip">Apply
                <span class="tooltiptext">Apply Pending Changes</span>
            </button>
        </div>

        <!-- Animation Controls -->
        <div class="animation-controls">
            <select id="animation-parameter">
                <option value="angle-n1">Angle at N1</option>
                <option value="angle-n2">Angle at N2</option>
                <option value="angle-n3">Angle at N3</option>
                <option value="edge-nc1">Edge NC1 (N1-N2)</option>
                <option value="edge-nc2">Edge NC2 (N1-N3)</option>
                <option value="edge-nc3">Edge NC3 (N2-N3)</option>
                <option value="median-n1i">Median N1-I</option>
                <option value="median-n2i">Median N2-I</option>
                <option value="median-n3i">Median N3-I</option>
                <option value="area">Area</option>
                <option value="perimeter">Perimeter</option>
            </select>
            <input type="number" id="animation-start" placeholder="Start Value" step="0.1">
            <input type="number" id="animation-end" placeholder="End Value" step="0.1">
            <button id="start-animation" class="tooltip">Animate
                <span class="tooltiptext">Start Animation</span>
            </button>
        </div>
    </div>

    <!-- Main Content Container -->
    <div id="main-content">
        <!-- Information Panel -->
        <div id="info-panel">
            <h2>Information Panel</h2>
            <div class="info-item">
                <strong>d Centroid to Incircle:</strong>
                <span id="d-centroid-incircle">0.0</span>
            </div>
            <div class="info-item">
                <strong>d Midpoint to Tangent:</strong>
                <ul>
                    <li>NC1: <span id="d-mid-nc1">0.0</span></li>
                    <li>NC2: <span id="d-mid-nc2">0.0</span></li>
                    <li>NC3: <span id="d-mid-nc3">0.0</span></li>
                </ul>
            </div>
            <div class="info-item">
                <strong>r Midpoint to Tangent:</strong>
                <ul>
                    <li>NC1: <span id="r-mid-nc1">0.0</span></li>
                    <li>NC2: <span id="r-mid-nc2">0.0</span></li>
                    <li>NC3: <span id="r-mid-nc3">0.0</span></li>
                </ul>
            </div>
        </div>

        <!-- Canvas and Legend Container -->
        <div id="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>

            <!-- Legend Section -->
            <div id="legend">
                <h3>Legend:</h3>
                <p>N1, N2, N3: Main nodes of the triangle</p>
                <p>I: Centroid of the triangle</p>
                <p>Incenter: Point where angle bisectors meet</p>
                <p>Incircle: Circle inscribed within the triangle</p>
                <p>NC1, NC2, NC3: Edge lengths (Node Channels)</p>
                <p>N1-I, N2-I, N3-I: Median Channel lengths</p>
                <p>Yellow Dots: Midpoints of the edges</p>
                <p>Light Blue Dots: Points of tangency with incircle</p>
                <p>ðŸ”’: Locked Node</p>
            </div>
        </div>
    </div>

    <script>
    // JavaScript Code Enhancements

    // TriangleSystem Class: Manages the Triangle, Calculations, and Rendering
    class TriangleSystem {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.system = {};
            this.showConnections = true;
            this.showAreas = true;
            this.showMidpoints = true;
            this.showIncircle = true;
            this.showIncenter = true;
            this.draggingNode = null;
            this.lockedNodes = { n1: false, n2: false, n3: false };
            this.centroidLocked = false;
            this.animationRequestId = null;
            this.animationStartTime = null;
            this.animationDuration = 2000; // 2 seconds
            this.animationParameter = null;
            this.animationStartValue = null;
            this.animationEndValue = null;

            this.initializeEventListeners();
            this.initializeSystem('equilateral');
        }

        // Initialize Triangle System based on Preset
        initializeSystem(preset = 'equilateral') {
            const side = 300;
            const height = (Math.sqrt(3) / 2) * side;

            switch (preset) {
                case 'equilateral':
                    this.system = {
                        n1: { x: -side / 2, y: -height / 3 },
                        n2: { x: side / 2, y: -height / 3 },
                        n3: { x: 0, y: (2 * height) / 3 },
                    };
                    break;
                case 'isosceles':
                    this.system = {
                        n1: { x: -side / 2, y: -height / 2 },
                        n2: { x: side / 2, y: -height / 2 },
                        n3: { x: 0, y: height },
                    };
                    break;
                case 'scalene':
                    this.system = {
                        n1: { x: -100, y: 150 },
                        n2: { x: 50, y: -50 },
                        n3: { x: 150, y: 100 },
                    };
                    break;
                case 'right':
                    this.system = {
                        n1: { x: 0, y: 0 },
                        n2: { x: 0, y: 200 },
                        n3: { x: 300, y: 0 },
                    };
                    break;
                case 'acute':
                    this.system = {
                        n1: { x: -100, y: 100 },
                        n2: { x: 100, y: 150 },
                        n3: { x: 150, y: -50 },
                    };
                    break;
                case 'obtuse':
                    this.system = {
                        n1: { x: -200, y: 0 },
                        n2: { x: 0, y: 0 },
                        n3: { x: 50, y: 200 },
                    };
                    break;
                default:
                    this.system = {
                        n1: { x: -side / 2, y: -height / 3 },
                        n2: { x: side / 2, y: -height / 3 },
                        n3: { x: 0, y: (2 * height) / 3 },
                    };
            }

            // Reset Locks
            this.lockedNodes = { n1: false, n2: false, n3: false };
            document.querySelectorAll('.lock-checkbox-input').forEach(cb => cb.checked = false);
            this.centroidLocked = false;
            document.getElementById('lock-centroid').checked = false;

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();
        }

        // Update Derived Points: Centroid, Midpoints, Incenter, Incircle
        updateDerivedPoints() {
            const N1 = this.system.n1;
            const N2 = this.system.n2;
            const N3 = this.system.n3;

            // Centroid (I)
            this.system.intelligence = {
                x: (N1.x + N2.x + N3.x) / 3,
                y: (N1.y + N2.y + N3.y) / 3,
            };

            // Midpoints
            this.system.midpoints = {
                m1: { x: (N2.x + N3.x) / 2, y: (N2.y + N3.y) / 2 }, // Opposite N1 (NC1)
                m2: { x: (N1.x + N3.x) / 2, y: (N1.y + N3.y) / 2 }, // Opposite N2 (NC2)
                m3: { x: (N1.x + N2.x) / 2, y: (N1.y + N2.y) / 2 }, // Opposite N3 (NC3)
            };

            // Incenter
            this.system.incenter = this.calculateIncenter();

            // Incircle Radius
            this.system.incircleRadius = this.calculateIncircleRadius();

            // Tangency Points
            this.system.tangencyPoints = this.calculateIncircleTangencyPoints();
        }

        // Draw the Entire System
        drawSystem() {
            const ctx = this.ctx;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            ctx.save();
            ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
            ctx.scale(1, -1); // Invert Y-axis for mathematical coordinates

            // Draw Axes
            this.drawAxes(ctx);

            // Draw Areas
            if (this.showAreas) {
                this.drawSubtriangles(ctx);
            }

            // Draw Main Triangle
            ctx.beginPath();
            ctx.moveTo(this.system.n1.x, this.system.n1.y);
            ctx.lineTo(this.system.n2.x, this.system.n2.y);
            ctx.lineTo(this.system.n3.x, this.system.n3.y);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Connections (Medians)
            if (this.showConnections) {
                this.drawConnections(ctx);
            }

            // Draw Midpoints
            if (this.showMidpoints) {
                this.drawMidpoints(ctx);
            }

            // Draw Incircle
            if (this.showIncircle) {
                this.drawIncircle(ctx);
                this.drawTangencyPoints(ctx);
            }

            // Draw Nodes
            this.drawNode(ctx, this.system.n1, 'red', 'N1', this.lockedNodes.n1);
            this.drawNode(ctx, this.system.n2, 'blue', 'N2', this.lockedNodes.n2);
            this.drawNode(ctx, this.system.n3, 'green', 'N3', this.lockedNodes.n3);

            // Draw Centroid
            this.drawNode(ctx, this.system.intelligence, 'white', 'I', this.centroidLocked);

            // Draw Incenter
            if (this.showIncenter) {
                this.drawNode(ctx, this.system.incenter, 'cyan', 'Incenter', false);
            }

            // Display Angles and Lengths
            this.displayInfo(ctx);

            ctx.restore();

            // Update All Dashboard Sections
            this.updateDerivedPoints();
            this.updateDashboard();
        }

        // Draw Coordinate Axes
        drawAxes(ctx) {
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;

            // X-axis
            ctx.beginPath();
            ctx.moveTo(-this.canvas.width / 2, 0);
            ctx.lineTo(this.canvas.width / 2, 0);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(0, -this.canvas.height / 2);
            ctx.lineTo(0, this.canvas.height / 2);
            ctx.stroke();
        }

        // Draw Subtriangles Areas
        drawSubtriangles(ctx) {
            const subtriangles = [
                { points: [this.system.n1, this.system.n2, this.system.intelligence], color: 'rgba(231,76,60,0.3)' }, // Red Subtriangle
                { points: [this.system.n3, this.system.n1, this.system.intelligence], color: 'rgba(46,204,113,0.3)' }, // Green Subtriangle
                { points: [this.system.n2, this.system.n3, this.system.intelligence], color: 'rgba(52,152,219,0.3)' }, // Blue Subtriangle
            ];

            subtriangles.forEach(tri => {
                ctx.beginPath();
                ctx.moveTo(tri.points[0].x, tri.points[0].y);
                ctx.lineTo(tri.points[1].x, tri.points[1].y);
                ctx.lineTo(tri.points[2].x, tri.points[2].y);
                ctx.closePath();
                ctx.fillStyle = tri.color;
                ctx.fill();
            });
        }

        // Draw Connections (Medians)
        drawConnections(ctx) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // Medians from nodes to centroid
            ['n1', 'n2', 'n3'].forEach(node => {
                ctx.beginPath();
                ctx.moveTo(this.system[node].x, this.system[node].y);
                ctx.lineTo(this.system.intelligence.x, this.system.intelligence.y);
                ctx.stroke();
            });

            ctx.setLineDash([]);
        }

        // Draw Midpoints
        drawMidpoints(ctx) {
            ctx.fillStyle = 'yellow';
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 1;

            ['m1', 'm2', 'm3'].forEach(mid => {
                const midpoint = this.system.midpoints[mid];
                // Draw midpoint
                ctx.beginPath();
                ctx.arc(midpoint.x, midpoint.y, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Draw line from midpoint to centroid
                ctx.beginPath();
                ctx.moveTo(midpoint.x, midpoint.y);
                ctx.lineTo(this.system.intelligence.x, this.system.intelligence.y);
                ctx.stroke();
            });
        }

        // Draw Incircle
        drawIncircle(ctx) {
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.system.incenter.x, this.system.incenter.y, this.system.incircleRadius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        // Draw Tangency Points on Incircle
        drawTangencyPoints(ctx) {
            ctx.fillStyle = 'lightblue';
            this.system.tangencyPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Draw Nodes and Labels
        drawNode(ctx, point, color, label, locked) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(label, point.x + 10, point.y + 5);

            // If node is locked, add a lock icon or visual indicator
            if (locked) {
                ctx.fillStyle = 'gold';
                ctx.font = '16px Arial';
                ctx.fillText('ðŸ”’', point.x - 12, point.y + 5);
            }
        }

        // Display Angles and Edge Lengths on Canvas
        displayInfo(ctx) {
            ctx.save();
            ctx.scale(1, -1); // Flip text back to normal

            ctx.fillStyle = '#ecf0f1';
            ctx.font = '14px Arial';

            // Display N1 Angle
            ctx.fillText(`N1 Angle: ${this.calculateAngles().n1.toFixed(1)}Â°`, this.system.n1.x - 30, -this.system.n1.y - 20);
            // Display N2 Angle
            ctx.fillText(`N2 Angle: ${this.calculateAngles().n2.toFixed(1)}Â°`, this.system.n2.x - 30, -this.system.n2.y + 10);
            // Display N3 Angle
            ctx.fillText(`N3 Angle: ${this.calculateAngles().n3.toFixed(1)}Â°`, this.system.n3.x - 30, -this.system.n3.y + 10);

            // Display Edge Lengths
            const lengths = this.calculateLengths();
            ctx.fillText(`NC1: ${lengths.l3.toFixed(1)}`, (this.system.n1.x + this.system.n2.x) / 2 - 20, -(this.system.n1.y + this.system.n2.y) / 2);
            ctx.fillText(`NC2: ${lengths.l2.toFixed(1)}`, (this.system.n1.x + this.system.n3.x) / 2 + 10, -(this.system.n1.y + this.system.n3.y) / 2 + 10);
            ctx.fillText(`NC3: ${lengths.l1.toFixed(1)}`, (this.system.n2.x + this.system.n3.x) / 2 - 20, -(this.system.n2.y + this.system.n3.y) / 2);

            ctx.restore();
        }

        // Calculate Angles at Each Node
        calculateAngles() {
            return {
                n1: this.calculateAngle(this.system.n2, this.system.n1, this.system.n3),
                n2: this.calculateAngle(this.system.n1, this.system.n2, this.system.n3),
                n3: this.calculateAngle(this.system.n1, this.system.n3, this.system.n2),
            };
        }

        // Calculate a Single Angle Given Three Points
        calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.hypot(v1.x, v1.y);
            const mag2 = Math.hypot(v2.x, v2.y);

            let angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
            if (isNaN(angle)) angle = 0;
            return angle;
        }

        // Calculate Edge Lengths
        calculateLengths() {
            return {
                l1: this.calculateDistance(this.system.n2, this.system.n3), // NC3
                l2: this.calculateDistance(this.system.n1, this.system.n3), // NC2
                l3: this.calculateDistance(this.system.n1, this.system.n2), // NC1
            };
        }

        // Calculate Distance Between Two Points
        calculateDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        // Calculate Incenter Using Angle Bisector Theorem
        calculateIncenter() {
            const a = this.calculateLengths().l1;
            const b = this.calculateLengths().l2;
            const c = this.calculateLengths().l3;
            const perimeter = a + b + c;
            const x = (a * this.system.n1.x + b * this.system.n2.x + c * this.system.n3.x) / perimeter;
            const y = (a * this.system.n1.y + b * this.system.n2.y + c * this.system.n3.y) / perimeter;
            return { x, y };
        }

        // Calculate Incircle Radius
        calculateIncircleRadius() {
            const area = this.calculateArea();
            const perimeter = this.calculateLengths().l1 + this.calculateLengths().l2 + this.calculateLengths().l3;
            return (2 * area) / perimeter;
        }

        // Calculate Area of Triangle Using Shoelace Formula
        calculateArea() {
            const { n1, n2, n3 } = this.system;
            return Math.abs((n1.x * (n2.y - n3.y) + n2.x * (n3.y - n1.y) + n3.x * (n1.y - n2.y)) / 2);
        }

        // Calculate Tangency Points on Incircle
        calculateIncircleTangencyPoints() {
            const { n1, n2, n3, incenter } = this.system;

            // Tangency point on side opposite to n1 (NC1)
            const tangencyA = this.findTangencyPoint(n2, n3, incenter);

            // Tangency point on side opposite to n2 (NC2)
            const tangencyB = this.findTangencyPoint(n1, n3, incenter);

            // Tangency point on side opposite to n3 (NC3)
            const tangencyC = this.findTangencyPoint(n1, n2, incenter);

            return [tangencyA, tangencyB, tangencyC];
        }

        // Helper Function to Find Tangency Point on a Given Side
        findTangencyPoint(p1, p2, incenter) {
            const a = this.calculateDistance(p1, p2);
            const b = this.calculateDistance(incenter, p1);
            const c = this.calculateDistance(incenter, p2);
            const s = (a + b + c) / 2;
            const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
            const h = (2 * area) / a;

            // Unit vector from p1 to p2
            const ux = (p2.x - p1.x) / a;
            const uy = (p2.y - p1.y) / a;

            // Distance from p1 to tangency point
            const d = (a + b - c) / 2;

            return {
                x: p1.x + ux * d,
                y: p1.y + uy * d,
            };
        }

        // Initialize Event Listeners for User Interactions
        initializeEventListeners() {
            // Canvas Events for Dragging Nodes
            this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));

            // Lock Controls
            document.getElementById('lock-n1').addEventListener('change', (e) => {
                this.lockedNodes.n1 = e.target.checked;
                this.updateLockVisuals('n1', e.target.checked);
            });
            document.getElementById('lock-n2').addEventListener('change', (e) => {
                this.lockedNodes.n2 = e.target.checked;
                this.updateLockVisuals('n2', e.target.checked);
            });
            document.getElementById('lock-n3').addEventListener('change', (e) => {
                this.lockedNodes.n3 = e.target.checked;
                this.updateLockVisuals('n3', e.target.checked);
            });
            document.getElementById('lock-centroid').addEventListener('change', (e) => {
                this.centroidLocked = e.target.checked;
                this.updateLockVisuals('intelligence', e.target.checked);
            });

            // Preset Buttons
            document.getElementById('equilateral').addEventListener('click', () => this.initializeSystem('equilateral'));
            document.getElementById('isosceles').addEventListener('click', () => this.initializeSystem('isosceles'));
            document.getElementById('scalene').addEventListener('click', () => this.initializeSystem('scalene'));
            document.getElementById('right').addEventListener('click', () => this.initializeSystem('right'));
            document.getElementById('acute').addEventListener('click', () => this.initializeSystem('acute'));
            document.getElementById('obtuse').addEventListener('click', () => this.initializeSystem('obtuse'));

            // Toggle Buttons
            document.getElementById('toggleMidpoints').addEventListener('click', () => {
                this.showMidpoints = !this.showMidpoints;
                this.drawSystem();
                this.updateToggleButtonText('toggleMidpoints', 'Midpoints');
            });
            document.getElementById('toggleIncircle').addEventListener('click', () => {
                this.showIncircle = !this.showIncircle;
                this.drawSystem();
                this.updateToggleButtonText('toggleIncircle', 'Incircle');
            });
            document.getElementById('toggleIncenter').addEventListener('click', () => {
                this.showIncenter = !this.showIncenter;
                this.drawSystem();
                this.updateToggleButtonText('toggleIncenter', 'Incenter');
            });
            document.getElementById('toggleMedians').addEventListener('click', () => {
                this.showConnections = !this.showConnections;
                this.drawSystem();
                this.updateToggleButtonText('toggleMedians', 'Medians');
            });
            document.getElementById('toggleAreas').addEventListener('click', () => {
                this.showAreas = !this.showAreas;
                this.drawSystem();
                this.updateToggleButtonText('toggleAreas', 'Areas');
            });

            // Apply Button
            document.getElementById('apply-button').addEventListener('click', () => this.processPendingChanges());

            // Animation Controls
            document.getElementById('start-animation').addEventListener('click', () => this.startAnimation());
        }

        // Update Toggle Button Text Based on State
        updateToggleButtonText(buttonId, label) {
            const button = document.getElementById(buttonId);
            if (button.textContent.includes('Show')) {
                button.textContent = label;
            } else {
                button.textContent = label;
            }
        }

        // Mouse Down Event: Start Dragging if Clicked on a Node
        onMouseDown(e) {
            const pos = this.getMousePos(e);
            const nodes = ['n1', 'n2', 'n3', 'intelligence'];
            for (let node of nodes) {
                let point = this.system[node];
                if (this.calculateDistance(pos, point) < 10) {
                    if (node === 'intelligence' && this.centroidLocked) return;
                    if (node !== 'intelligence' && this.lockedNodes[node]) return;
                    this.draggingNode = node;
                    return;
                }
            }
        }

        // Mouse Move Event: Update Node Position if Dragging
        onMouseMove(e) {
            const pos = this.getMousePos(e);
            if (this.draggingNode) {
                if (this.draggingNode === 'intelligence' && this.centroidLocked) return;
                if (this.draggingNode !== 'intelligence' && this.lockedNodes[this.draggingNode]) return;

                this.system[this.draggingNode].x = pos.x;
                this.system[this.draggingNode].y = pos.y;

                this.updateDerivedPoints();
                this.updateDashboard();
                this.drawSystem();
            }
        }

        // Mouse Up Event: Stop Dragging
        onMouseUp(e) {
            this.draggingNode = null;
        }

        // Get Mouse Position Relative to Canvas Coordinates
        getMousePos(evt) {
            const rect = this.canvas.getBoundingClientRect();
            const mx = evt.clientX - rect.left - this.canvas.width / 2;
            const my = (evt.clientY - rect.top - this.canvas.height / 2) * -1;
            return { x: mx, y: my };
        }

        // Handle Apply Button Click
        processPendingChanges() {
            // Gather all input values
            const inputs = document.querySelectorAll('#dashboard input');
            let newSystem = { ...this.system }; // Clone current system

            // Flags to determine if nodes have been updated
            let nodesUpdated = false;

            // Update Nodes
            ['n1', 'n2', 'n3', 'intelligence'].forEach(node => {
                const xInput = document.getElementById(`node-${node}-x`);
                const yInput = document.getElementById(`node-${node}-y`);
                if (xInput && yInput && !this.isNodeLocked(node)) {
                    const x = parseFloat(xInput.value);
                    const y = parseFloat(yInput.value);
                    if (!isNaN(x) && !isNaN(y)) {
                        newSystem[node].x = x;
                        newSystem[node].y = y;
                        nodesUpdated = true;
                    }
                }
            });

            // Update Channel Lengths
            ['nc1', 'nc2', 'nc3'].forEach(edge => {
                const edgeInput = document.getElementById(`edge-${edge}`);
                if (edgeInput) {
                    const newLength = parseFloat(edgeInput.value);
                    if (!isNaN(newLength) && newLength > 0) {
                        // Adjust the position of the third node to achieve the desired edge length
                        // This is a simplified approach and may not maintain all triangle properties
                        // A more robust geometric solver would be needed for precise adjustments
                        // Here, we'll scale the entire triangle uniformly based on the desired edge length

                        const currentLengths = this.calculateLengths();
                        const edgeMap = { nc1: 'l3', nc2: 'l2', nc3: 'l1' };
                        const currentLength = currentLengths[edgeMap[edge]];
                        const scaleFactor = newLength / currentLength;

                        ['n1', 'n2', 'n3'].forEach(node => {
                            newSystem[node].x = this.system.intelligence.x + (this.system[node].x - this.system.intelligence.x) * scaleFactor;
                            newSystem[node].y = this.system.intelligence.y + (this.system[node].y - this.system.intelligence.y) * scaleFactor;
                        });

                        nodesUpdated = true;
                    }
                }
            });

            // Update Median Lengths if Needed
            ['n1i', 'n2i', 'n3i'].forEach(median => {
                const medianInput = document.getElementById(`median-${median}`);
                if (medianInput) {
                    const newMedian = parseFloat(medianInput.value);
                    if (!isNaN(newMedian) && newMedian > 0) {
                        // Adjusting median lengths is complex; typically, medians are derived from node positions
                        // For simplicity, this feature is left as a placeholder
                        // Implementing it requires solving geometric constraints
                        // You can enhance this method based on your specific requirements
                    }
                }
            });

            // Update the system if any changes were made
            if (nodesUpdated) {
                this.system = newSystem;
                this.updateDerivedPoints();
                this.updateDashboard();
                this.drawSystem();
            } else {
                alert('No valid changes detected to apply.');
            }
        }

        // Check if a node is locked
        isNodeLocked(node) {
            if (node === 'intelligence') {
                return this.centroidLocked;
            }
            return this.lockedNodes[node];
        }

        // Update Dashboard Fields with Calculated Values
        updateDashboard() {
            const angles = this.calculateAngles();
            const lengths = this.calculateLengths();

            // Update System Section
            document.getElementById('system-perimeter').value = (lengths.l1 + lengths.l2 + lengths.l3).toFixed(1);
            document.getElementById('system-area').value = this.calculateArea().toFixed(1);

            // Update Subsystems Section
            // Assuming each subsystem has 1/3 of the total area
            const mainArea = this.calculateArea();
            const subsystemArea = mainArea / 3;
            document.getElementById('subsystem-1-area').value = subsystemArea.toFixed(1);
            document.getElementById('subsystem-2-area').value = subsystemArea.toFixed(1);
            document.getElementById('subsystem-3-area').value = subsystemArea.toFixed(1);

            // Perimeters: Sum of two sides and median for each subsystem
            document.getElementById('subsystem-1-perimeter').value = (lengths.l3 + this.calculateDistance(this.system.n1, this.system.intelligence) + this.calculateDistance(this.system.n2, this.system.intelligence)).toFixed(1);
            document.getElementById('subsystem-2-perimeter').value = (lengths.l2 + this.calculateDistance(this.system.n1, this.system.intelligence) + this.calculateDistance(this.system.n3, this.system.intelligence)).toFixed(1);
            document.getElementById('subsystem-3-perimeter').value = (lengths.l1 + this.calculateDistance(this.system.n2, this.system.intelligence) + this.calculateDistance(this.system.n3, this.system.intelligence)).toFixed(1);

            // Centroid Angles: Placeholder values (Actual calculation requires additional geometric logic)
            document.getElementById('subsystem-1-centroid-angle').value = angles.n1.toFixed(1);
            document.getElementById('subsystem-2-centroid-angle').value = angles.n2.toFixed(1);
            document.getElementById('subsystem-3-centroid-angle').value = angles.n3.toFixed(1);

            // Adjacent Subangles: Placeholder values (Requires complex geometric calculations)
            document.getElementById('subsystem-1-adj-subangle-a').value = '0.0'; // Placeholder
            document.getElementById('subsystem-2-adj-subangle-a').value = '0.0'; // Placeholder
            document.getElementById('subsystem-3-adj-subangle-a').value = '0.0'; // Placeholder

            document.getElementById('subsystem-1-adj-subangle-b').value = '0.0'; // Placeholder
            document.getElementById('subsystem-2-adj-subangle-b').value = '0.0'; // Placeholder
            document.getElementById('subsystem-3-adj-subangle-b').value = '0.0'; // Placeholder

            // Update Channels Section
            document.getElementById('edge-nc1').value = lengths.l3.toFixed(1);
            document.getElementById('edge-nc2').value = lengths.l2.toFixed(1);
            document.getElementById('edge-nc3').value = lengths.l1.toFixed(1);

            document.getElementById('median-n1i').value = this.calculateDistance(this.system.n1, this.system.intelligence).toFixed(1);
            document.getElementById('median-n2i').value = this.calculateDistance(this.system.n2, this.system.intelligence).toFixed(1);
            document.getElementById('median-n3i').value = this.calculateDistance(this.system.n3, this.system.intelligence).toFixed(1);

            // Update Nodes Section
            ['n1', 'n2', 'n3'].forEach(node => {
                document.getElementById(`node-${node}-x`).value = this.system[node].x.toFixed(1);
                document.getElementById(`node-${node}-y`).value = this.system[node].y.toFixed(1);
                document.getElementById(`node-${node}-angle`).value = angles[node].toFixed(1);
            });

            // Update Centers Section (Centroid positions and Incenter)
            document.getElementById('centroid-x').value = this.system.intelligence.x.toFixed(1);
            document.getElementById('centroid-y').value = this.system.intelligence.y.toFixed(1);
            document.getElementById('incenter-x').value = this.system.incenter.x.toFixed(1);
            document.getElementById('incenter-y').value = this.system.incenter.y.toFixed(1);
            document.getElementById('incircle-area').value = (Math.PI * Math.pow(this.system.incircleRadius, 2)).toFixed(1);
            document.getElementById('incircle-perimeter').value = (2 * Math.PI * this.system.incircleRadius).toFixed(1);

            // Angles at Incenter: Placeholder values (Requires additional geometric calculations)
            document.getElementById('angle-ss1').value = '0.0'; // Placeholder
            document.getElementById('angle-ss2').value = '0.0'; // Placeholder
            document.getElementById('angle-ss3').value = '0.0'; // Placeholder

            // Update Information Panel
            // Distance from Centroid to Incenter
            const d_centroid_incircle = this.calculateDistance(this.system.intelligence, this.system.incenter);
            document.getElementById('d-centroid-incircle').textContent = d_centroid_incircle.toFixed(1);

            // Distances from Midpoints to Tangency Points
            const d_mid_nc1 = this.calculateDistance(this.system.midpoints.m1, this.system.tangencyPoints[0]);
            const d_mid_nc2 = this.calculateDistance(this.system.midpoints.m2, this.system.tangencyPoints[1]);
            const d_mid_nc3 = this.calculateDistance(this.system.midpoints.m3, this.system.tangencyPoints[2]);
            document.getElementById('d-mid-nc1').textContent = d_mid_nc1.toFixed(1);
            document.getElementById('d-mid-nc2').textContent = d_mid_nc2.toFixed(1);
            document.getElementById('d-mid-nc3').textContent = d_mid_nc3.toFixed(1);

            // Distances from Incenter to Midpoints (r Mid to Tangent)
            const r_mid_nc1 = this.calculateDistance(this.system.incenter, this.system.midpoints.m1);
            const r_mid_nc2 = this.calculateDistance(this.system.incenter, this.system.midpoints.m2);
            const r_mid_nc3 = this.calculateDistance(this.system.incenter, this.system.midpoints.m3);
            document.getElementById('r-mid-nc1').textContent = r_mid_nc1.toFixed(1);
            document.getElementById('r-mid-nc2').textContent = r_mid_nc2.toFixed(1);
            document.getElementById('r-mid-nc3').textContent = r_mid_nc3.toFixed(1);
        }

        // Update Lock Visuals (Redraw System)
        updateLockVisuals(node, isLocked) {
            this.drawSystem();
        }

        // Adjust Angle at a Given Node (Placeholder Logic)
        adjustAngle(node, newAngle) {
            // Implementing angle adjustments requires complex geometric computations
            // For demonstration, we'll adjust the position of the node to reflect the new angle
            // This is a simplified approach and may not maintain all triangle properties

            const oppositeNode = this.getOppositeNode(node);
            if (!oppositeNode) return;

            const centroid = this.system.intelligence;
            const dx = this.system[node].x - centroid.x;
            const dy = this.system[node].y - centroid.y;
            const distance = Math.hypot(dx, dy);

            const radians = newAngle * (Math.PI / 180);
            const new_x = centroid.x + distance * Math.cos(radians);
            const new_y = centroid.y + distance * Math.sin(radians);

            this.system[node].x = new_x;
            this.system[node].y = new_y;

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();
        }

        // Get Opposite Node for Angle Adjustment (Helper Function)
        getOppositeNode(node) {
            switch (node) {
                case 'n1':
                    return 'n2';
                case 'n2':
                    return 'n3';
                case 'n3':
                    return 'n1';
                default:
                    return null;
            }
        }

        // Adjust Edge Lengths (Placeholder Logic)
        adjustEdges(edges) {
            // Implementing edge adjustments requires recalculating node positions to match new lengths
            // This is complex and requires solving geometric constraints
            // For demonstration, we'll scale the triangle uniformly based on edge adjustments

            // Determine the scale factor based on one of the edges
            let scaleFactor = 1;
            if (edges.nc1) {
                const currentLength = this.calculateLengths().l3;
                scaleFactor = edges.nc1 / currentLength;
            } else if (edges.nc2) {
                const currentLength = this.calculateLengths().l2;
                scaleFactor = edges.nc2 / currentLength;
            } else if (edges.nc3) {
                const currentLength = this.calculateLengths().l1;
                scaleFactor = edges.nc3 / currentLength;
            }

            // Scale all node positions relative to centroid
            ['n1', 'n2', 'n3'].forEach(node => {
                this.system[node].x = this.system.intelligence.x + (this.system[node].x - this.system.intelligence.x) * scaleFactor;
                this.system[node].y = this.system.intelligence.y + (this.system[node].y - this.system.intelligence.y) * scaleFactor;
            });

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();
        }

        // Start Animation Based on Selected Parameter
        startAnimation() {
            const parameter = document.getElementById('animation-parameter').value;
            const startValue = parseFloat(document.getElementById('animation-start').value);
            const endValue = parseFloat(document.getElementById('animation-end').value);

            if (isNaN(startValue) || isNaN(endValue)) {
                alert('Please enter valid numeric values for start and end values.');
                return;
            }

            this.animationParameter = parameter;
            this.animationStartValue = startValue;
            this.animationEndValue = endValue;
            this.animationStartTime = null;

            if (this.animationRequestId) {
                cancelAnimationFrame(this.animationRequestId);
            }

            this.animationRequestId = requestAnimationFrame(this.animate.bind(this));
        }

        // Animation Loop
        animate(timestamp) {
            if (!this.animationStartTime) this.animationStartTime = timestamp;
            const elapsed = timestamp - this.animationStartTime;
            const progress = Math.min(elapsed / this.animationDuration, 1);
            const currentValue = this.animationStartValue + (this.animationEndValue - this.animationStartValue) * progress;

            // Update the parameter based on currentValue
            this.updateAnimatedParameter(this.animationParameter, currentValue);

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();

            if (progress < 1) {
                this.animationRequestId = requestAnimationFrame(this.animate.bind(this));
            } else {
                this.animationRequestId = null;
            }
        }

        // Update Specified Parameter During Animation
        updateAnimatedParameter(parameter, value) {
            switch (parameter) {
                case 'angle-n1':
                    this.adjustAngle('n1', value);
                    break;
                case 'angle-n2':
                    this.adjustAngle('n2', value);
                    break;
                case 'angle-n3':
                    this.adjustAngle('n3', value);
                    break;
                case 'edge-nc1':
                    this.adjustEdges({ 'nc1': value });
                    break;
                case 'edge-nc2':
                    this.adjustEdges({ 'nc2': value });
                    break;
                case 'edge-nc3':
                    this.adjustEdges({ 'nc3': value });
                    break;
                case 'median-n1i':
                    // Placeholder for median adjustment
                    break;
                case 'median-n2i':
                    // Placeholder for median adjustment
                    break;
                case 'median-n3i':
                    // Placeholder for median adjustment
                    break;
                case 'area':
                    this.adjustArea(value);
                    break;
                case 'perimeter':
                    this.adjustPerimeter(value);
                    break;
                default:
                    break;
            }
        }

        // Adjust Area by Scaling the Triangle
        adjustArea(newArea) {
            const currentArea = this.calculateArea();
            if (currentArea === 0) return;
            const scaleFactor = Math.sqrt(newArea / currentArea);

            // Scale all node positions relative to centroid
            ['n1', 'n2', 'n3'].forEach(node => {
                this.system[node].x = this.system.intelligence.x + (this.system[node].x - this.system.intelligence.x) * scaleFactor;
                this.system[node].y = this.system.intelligence.y + (this.system[node].y - this.system.intelligence.y) * scaleFactor;
            });

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();
        }

        // Adjust Perimeter by Scaling the Triangle
        adjustPerimeter(newPerimeter) {
            const currentPerimeter = this.calculateLengths().l1 + this.calculateLengths().l2 + this.calculateLengths().l3;
            if (currentPerimeter === 0) return;
            const scaleFactor = newPerimeter / currentPerimeter;

            // Scale all node positions relative to centroid
            ['n1', 'n2', 'n3'].forEach(node => {
                this.system[node].x = this.system.intelligence.x + (this.system[node].x - this.system.intelligence.x) * scaleFactor;
                this.system[node].y = this.system.intelligence.y + (this.system[node].y - this.system.intelligence.y) * scaleFactor;
            });

            this.updateDerivedPoints();
            this.updateDashboard();
            this.drawSystem();
        }
    }

    // Initialize the Triangle System
    const canvas = document.getElementById('canvas');
    const triangleSystem = new TriangleSystem(canvas);
    </script>
</body>
</html>